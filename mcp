#!/usr/bin/env bash

# MCP Server Selector v2.0
# Production-grade TUI for managing Claude Code MCP servers
# Cross-platform (Linux/macOS) - Never modifies global config

# ============================================================================
# BASH VERSION CHECK (requires Bash 4.0+ for associative arrays)
# ============================================================================
if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
    echo "Error: This script requires Bash 4.0 or higher (found: $BASH_VERSION)" >&2
    echo "" >&2
    if [[ "$(uname -s)" == "Darwin" ]]; then
        echo "macOS ships with Bash 3.2 by default. You have several options:" >&2
        echo "" >&2
        echo "Option 1: Install modern Bash via Homebrew (recommended)" >&2
        echo "  brew install bash" >&2
        echo "  # Then run: /opt/homebrew/bin/bash $(command -v "$0")" >&2
        echo "" >&2
        echo "Option 2: Install via MacPorts" >&2
        echo "  sudo port install bash" >&2
        echo "  # Then run: /opt/local/bin/bash $(command -v "$0")" >&2
        echo "" >&2
        echo "Option 3: Add modern Bash to your PATH (permanent fix)" >&2
        echo "  Add to ~/.zshrc or ~/.bash_profile:" >&2
        echo "    export PATH=\"/opt/homebrew/bin:\$PATH\"  # for Homebrew" >&2
        echo "    # OR" >&2
        echo "    export PATH=\"/opt/local/bin:\$PATH\"     # for MacPorts" >&2
        echo "" >&2
        echo "Quick test: Run 'bash --version' to check your default bash version." >&2
    else
        echo "Please install Bash 4.0+ via your package manager." >&2
    fi
    exit 1
fi

set -euo pipefail

# ============================================================================
# CONSTANTS & GLOBALS
# ============================================================================

readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="2.0.0"  # Bug workarounds, audit mode, debug commands

# Command-line mode flags (set by argument parsing)
CMD_MODE=""           # "" = TUI mode, "audit" | "validate" | "debug" | "fix" | "restore" | "help" | "export" | "sync" | "context" | "enable" | "disable"
CMD_ARG=""            # Argument for commands that need one (e.g., server name for --debug-precedence)
STRICT_DISABLE=false  # Convert ORANGE servers to RED before launch
AUDIT_JSON=false      # Output audit results as JSON
FIX_APPLY=false       # Apply fixes without confirmation
QUIET_MODE=false      # Suppress non-essential output (for hook usage)
CMD_ALL=false         # For enable/disable --all flag
EXPORT_CSV=false      # Output --export-disabled as CSV format
declare -a CMD_SERVERS=()  # Server names for enable/disable commands

# TUI filter state (persists during fzf session)
FILTER_TYPE="all"     # all | mcpjson | direct | plugin | enterprise | blocked | orange

# Performance: FAST_MODE skips runtime detection (saves 5-8 seconds)
# - Default: true (instant startup)
# - Disable: FAST_MODE=false ./mcp (for debugging)
# - ORANGE state still works via disabledMcpServers detection

# Paths
readonly BACKUP_DIR="$HOME/.claude/backups"

# ============================================================================
# ENTERPRISE CONFIGURATION PATHS
# ============================================================================

# Get platform-specific path for managed-mcp.json
# Returns: Path string or empty if not found
# Handles: Linux, macOS, WSL (checks both Windows and Linux paths)
get_enterprise_mcp_path() {
    # Detect WSL first - check both Windows and Linux paths
    if grep -qi microsoft /proc/version 2>/dev/null; then
        local win_path="/mnt/c/ProgramData/ClaudeCode/managed-mcp.json"
        local lin_path="/etc/claude-code/managed-mcp.json"
        [[ -f "$win_path" ]] && echo "$win_path" && return 0
        [[ -f "$lin_path" ]] && echo "$lin_path" && return 0
        return 1
    elif [[ "$(uname -s)" == "Darwin" ]]; then
        echo "/Library/Application Support/ClaudeCode/managed-mcp.json"
        return 0
    else
        echo "/etc/claude-code/managed-mcp.json"
        return 0
    fi
}

# Get platform-specific path for managed-settings.json
# Returns: Path string or empty if not found
get_enterprise_settings_path() {
    if grep -qi microsoft /proc/version 2>/dev/null; then
        local win_path="/mnt/c/ProgramData/ClaudeCode/managed-settings.json"
        local lin_path="/etc/claude-code/managed-settings.json"
        [[ -f "$win_path" ]] && echo "$win_path" && return 0
        [[ -f "$lin_path" ]] && echo "$lin_path" && return 0
        return 1
    elif [[ "$(uname -s)" == "Darwin" ]]; then
        echo "/Library/Application Support/ClaudeCode/managed-settings.json"
        return 0
    else
        echo "/etc/claude-code/managed-settings.json"
        return 0
    fi
}

# Color codes
readonly COLOR_RESET='\033[0m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_CYAN='\033[0;36m'
readonly COLOR_WHITE='\033[1m'
readonly COLOR_ORANGE='\033[38;2;213;97;38m'  # Claude Code brand color: rgb(213, 97, 38)
readonly COLOR_GREY='\033[90m'  # Light grey for headers

# Markers
readonly MARK_ERROR="✗"
readonly MARK_SUCCESS="✓"
readonly MARK_WARNING="⚠"
readonly MARK_INFO="→"

# State file (created in main, cleaned up via trap)
STATE_FILE=""

# Settings file path (determined during discovery)
SETTINGS_FILE_PATH=""
SETTINGS_SCOPE=""

# Enterprise mode flags
ENTERPRISE_MODE="none"        # none|active|lockdown
ENTERPRISE_SERVER_COUNT=0
RESTRICTION_TYPE="none"       # none|allowlist|denylist|both

# Restriction data
declare -a ALLOWED_SERVERS=()
declare -a DENIED_SERVERS=()

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Portable realpath implementation (works on Linux + macOS)
# Args: $1 - path to resolve
# Returns: absolute path
realpath_portable() {
    local path="$1"

    if [[ -d "$path" ]]; then
        (cd "$path" && pwd)
    elif [[ -e "$path" ]]; then
        local dir=$(dirname "$path")
        local base=$(basename "$path")
        (cd "$dir" && echo "$(pwd)/$base")
    else
        echo "$path"
    fi
}

# Detect operating system
# Returns: "Linux" or "Darwin" or "Unknown"
detect_os() {
    local os
    os=$(uname -s)
    echo "$os"
}

# Messaging utilities
msg_info() {
    echo -e "${COLOR_CYAN}${MARK_INFO}${COLOR_RESET} $*"
}

msg_success() {
    echo -e "${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $*"
}

msg_error() {
    echo -e "${COLOR_RED}${MARK_ERROR}${COLOR_RESET} $*" >&2
}

msg_warning() {
    echo -e "${COLOR_YELLOW}${MARK_WARNING}${COLOR_RESET} $*"
}

msg_header() {
    echo -e "${COLOR_WHITE}${COLOR_CYAN}$*${COLOR_RESET}"
}

# Show progress message with animation
# Args: $1 - message
# Usage: msg_progress "Loading..." &; PROGRESS_PID=$!; ...; kill $PROGRESS_PID 2>/dev/null
msg_progress() {
    local message="$1"
    local frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
    local frame_count=${#frames[@]}
    local i=0

    # Hide cursor
    tput civis 2>/dev/null || true

    while true; do
        printf "\r${COLOR_CYAN}${frames[$i]}${COLOR_RESET} $message"
        i=$(((i + 1) % frame_count))
        sleep 0.1
    done
}

# Stop progress message
# Args: $1 - PID of progress process
stop_progress() {
    local pid="$1"
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
        kill "$pid" 2>/dev/null || true
        wait "$pid" 2>/dev/null || true
    fi
    printf "\r\033[K"  # Clear line
    tput cnorm 2>/dev/null || true  # Show cursor
}

# Check if running inside a Claude session and warn user
check_session_context() {
    # Check for various indicators of a Claude session
    local in_session=false

    # Check for CLAUDE_SESSION_ID environment variable
    if [[ -n "${CLAUDE_SESSION_ID:-}" ]]; then
        in_session=true
    fi

    # Check for CLAUDE_CONVERSATION_ID
    if [[ -n "${CLAUDE_CONVERSATION_ID:-}" ]]; then
        in_session=true
    fi

    # Check if parent process is Claude
    if [[ -n "${CLAUDE_CODE:-}" ]]; then
        in_session=true
    fi

    # Check if invoked from within a Claude tool call
    if [[ -n "${MCP_TOOL_CALL:-}" ]]; then
        in_session=true
    fi

    if [[ "$in_session" == true ]]; then
        echo ""
        echo -e "${COLOR_YELLOW}╭────────────────────────────────────────────────────────────╮${COLOR_RESET}"
        echo -e "${COLOR_YELLOW}│${COLOR_RESET} ${COLOR_YELLOW}${MARK_WARNING} Running inside Claude session${COLOR_RESET}                          ${COLOR_YELLOW}│${COLOR_RESET}"
        echo -e "${COLOR_YELLOW}│${COLOR_RESET}   Changes will take effect on ${COLOR_WHITE}next session restart${COLOR_RESET}        ${COLOR_YELLOW}│${COLOR_RESET}"
        echo -e "${COLOR_YELLOW}│${COLOR_RESET}                                                            ${COLOR_YELLOW}│${COLOR_RESET}"
        echo -e "${COLOR_YELLOW}│${COLOR_RESET}   Use ${COLOR_CYAN}/mcp${COLOR_RESET} or ${COLOR_CYAN}@mention${COLOR_RESET} for in-session toggles              ${COLOR_YELLOW}│${COLOR_RESET}"
        echo -e "${COLOR_YELLOW}│${COLOR_RESET}   (Note: in-session toggles are NOT persisted)             ${COLOR_YELLOW}│${COLOR_RESET}"
        echo -e "${COLOR_YELLOW}╰────────────────────────────────────────────────────────────╯${COLOR_RESET}"
        echo ""
        sleep 1  # Brief pause to ensure user sees the warning
    fi
}

# Warn if running inside a Claude session (for subcommands)
# Returns 0 if NOT in session, 1 if in session
# Used by enable/disable/strict-disable commands to warn user
warn_if_in_session() {
    local in_session=false

    # Check for various indicators of a Claude session
    if [[ -n "${CLAUDE_SESSION_ID:-}" ]]; then
        in_session=true
    fi
    if [[ -n "${CLAUDE_CONVERSATION_ID:-}" ]]; then
        in_session=true
    fi
    if [[ -n "${CLAUDE_CODE:-}" ]]; then
        in_session=true
    fi
    if [[ -n "${MCP_TOOL_CALL:-}" ]]; then
        in_session=true
    fi

    if [[ "$in_session" == true ]]; then
        if [[ "$QUIET_MODE" != true ]]; then
            echo ""
            msg_warning "Running inside Claude session - changes may not take effect until restart"
            msg_info "Tip: Use ${COLOR_CYAN}/mcp${COLOR_RESET} for in-session server management"
            echo ""
        fi
        return 1
    fi

    return 0
}

# Get safe terminal width for lines
# Returns: width (defaults to 60 for narrow terminals)
get_term_width() {
    local cols
    cols=$(tput cols 2>/dev/null || echo 80)
    # Cap at reasonable max to prevent overflow, min at 60
    if [[ $cols -gt 100 ]]; then
        echo 80
    elif [[ $cols -lt 60 ]]; then
        echo 60
    else
        echo $((cols - 10))
    fi
}

# Generate horizontal line with character
# Args: $1 - character, $2 - width (optional, defaults to term width)
gen_line() {
    local char="${1:-─}"
    local width="${2:-$(get_term_width)}"
    printf '%*s' "$width" | tr ' ' "$char"
}

# Abbreviate path in fish-shell style
# Args: $1 - path to abbreviate
# Returns: abbreviated path (e.g., ~/.c/s.local.json)
abbreviate_path() {
    local path="$1"

    # Replace home directory with ~
    path="${path/#$HOME/\~}"

    # If path is in current directory, show as relative
    # Use exported MCP_CURRENT_DIR if available (for fzf preview context)
    local cwd="${MCP_CURRENT_DIR:-$(pwd)}"
    if [[ "$path" == "$cwd/"* ]]; then
        path="./${path#$cwd/}"
    elif [[ "$path" == "$cwd" ]]; then
        path="."
    fi

    # Abbreviate directory names (keep first letter only for non-terminal dirs)
    # Only abbreviate paths with 4+ components for readability
    local IFS='/'
    local -a parts=($path)
    local num_parts=${#parts[@]}
    local last_idx=$((num_parts - 1))

    # If path has fewer than 4 components, don't abbreviate (keeps it readable)
    if [[ $num_parts -lt 4 ]]; then
        echo "$path"
        return
    fi

    local result=""
    for i in "${!parts[@]}"; do
        local part="${parts[$i]}"

        # Skip empty components
        if [[ -z "$part" ]]; then
            continue
        fi

        # Keep special prefixes as-is (~, ., ..)
        if [[ "$part" == "~" ]] || [[ "$part" == "." ]] || [[ "$part" == ".." ]]; then
            result+="$part"
        elif [[ $i -eq $last_idx ]]; then
            # Last component - keep full name
            result+="/$part"
        else
            # Intermediate directory - abbreviate to first letter
            result+="/${part:0:1}"
        fi
    done

    # Clean up leading slash if path starts with ~ or .
    result="${result#/}"

    echo "$result"
}

# ============================================================================
# HELP AND COMMAND-LINE INTERFACE
# ============================================================================

# Show help message
show_help() {
    cat << 'EOF'
MCP Server Selector v2.0.0 - Claude Code MCP Server Management TUI

USAGE:
    mcp [OPTIONS] [-- CLAUDE_ARGS...]

INTERACTIVE MODE (default):
    mcp                     Launch TUI to manage MCP servers
    mcp -- --resume         Launch TUI, then pass --resume to Claude

DIAGNOSTIC COMMANDS:
    mcp --audit             Check configuration health and report issues
    mcp --audit --json      Output audit results as JSON
    mcp --validate          Quick validation of all config files
    mcp --debug-precedence SERVER
                            Show how a server's state is resolved

REPAIR COMMANDS:
    mcp --fix-config        Interactive repair of configuration issues
    mcp --fix-config --apply
                            Apply repairs without confirmation
    mcp --restore-plugin PLUGIN@MARKETPLACE
                            Restore a hard-disabled plugin
    mcp --rollback          Restore configuration from a backup

INTEGRATION COMMANDS:
    mcp --export-disabled   Export disabled servers (for hook automation)
    mcp --export-disabled --json
                            Export as JSON format
    mcp --export-disabled --csv
                            Export as CSV format (server,state,type)
    mcp --export-disabled --quiet
                            Export without headers (machine-readable)
    mcp --sync-check        Compare config vs runtime state
    mcp --context-report    Show context token usage per server

SERVER COMMANDS:
    mcp enable SERVER [SERVER...]
                            Enable specific servers
    mcp disable SERVER [SERVER...]
                            Disable specific servers
    mcp enable --all        Enable all servers
    mcp disable --all       Disable all servers
    mcp enable --json       Output result as JSON
    mcp disable --json      Output result as JSON

OPTIONS:
    --strict-disable        Convert ORANGE (runtime-disabled) servers to RED
                            before launching Claude (workaround for bug #13311)
    --quiet, -q             Suppress non-essential output
    --version               Show version information
    --help                  Show this help message

TUI KEYBINDINGS:
    SPACE       Toggle server (RED → GREEN → ORANGE → RED)
    ALT-M       Migrate Direct server to project
    ALT-H       Hard disable plugin (hidden from UI)
    ALT-E       Enable all servers
    ALT-D       Disable all servers
    ALT-1       Filter: MCPJSON servers only
    ALT-2       Filter: Direct servers only
    ALT-3       Filter: Plugin servers only
    ALT-4       Filter: Enterprise servers only
    ALT-0       Show all servers (reset filter)
    ALT-B       Filter: Blocked servers only
    ALT-O       Filter: ORANGE (runtime-disabled) only
    CTRL-A      Add new server
    CTRL-X      Remove server
    CTRL-R      Refresh runtime status
    ENTER       Save changes and launch Claude
    ESC         Cancel without saving

EXAMPLES:
    mcp --audit                         # Check for config issues
    mcp --debug-precedence fetch        # Why is 'fetch' enabled/disabled?
    mcp --fix-config                    # Fix detected issues interactively
    mcp --strict-disable                # Ensure disabled servers stay disabled
    mcp --restore-plugin mcp-fetch@marketplace  # Re-enable hidden plugin
    mcp --rollback                      # Restore from a previous backup
    mcp --export-disabled --quiet       # Get disabled servers for hooks
    mcp --sync-check                    # Check for bug #13311 issues
    mcp --context-report                # See context token usage
    mcp enable fetch github             # Enable specific servers
    mcp disable --all                   # Disable all servers
    mcp enable --json fetch             # Enable and output JSON result

HOOK INTEGRATION:
    Example SessionStart hook in .claude/settings.json:
    {
      "hooks": {
        "SessionStart": [{
          "type": "command",
          "command": "./mcp --strict-disable --quiet"
        }]
      }
    }

    This ensures ORANGE servers are converted to RED before each session,
    working around bug #13311 where disabledMcpServers is not enforced.

For more information, see: https://github.com/henkisdabro/Claude-Code-MCP-Server-Selector
EOF
}

# Parse command-line arguments
# Sets global CMD_MODE, CMD_ARG, STRICT_DISABLE, AUDIT_JSON, FIX_APPLY
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                CMD_MODE="help"
                return 0
                ;;
            --version|-v)
                echo "MCP Server Selector v${VERSION}"
                exit 0
                ;;
            --audit)
                CMD_MODE="audit"
                shift
                ;;
            --validate)
                CMD_MODE="validate"
                shift
                ;;
            --debug-precedence)
                CMD_MODE="debug"
                shift
                if [[ $# -eq 0 ]] || [[ "$1" == -* ]]; then
                    msg_error "--debug-precedence requires a server name"
                    exit 1
                fi
                CMD_ARG="$1"
                shift
                ;;
            --fix-config)
                CMD_MODE="fix"
                shift
                ;;
            --restore-plugin)
                CMD_MODE="restore"
                shift
                if [[ $# -eq 0 ]] || [[ "$1" == -* ]]; then
                    msg_error "--restore-plugin requires a plugin name (e.g., mcp-fetch@marketplace)"
                    exit 1
                fi
                CMD_ARG="$1"
                shift
                ;;
            --rollback)
                CMD_MODE="rollback"
                shift
                ;;
            --export-disabled)
                CMD_MODE="export"
                shift
                ;;
            --sync-check)
                CMD_MODE="sync"
                shift
                ;;
            --context-report)
                CMD_MODE="context"
                shift
                ;;
            --quiet|-q)
                QUIET_MODE=true
                shift
                ;;
            --strict-disable)
                STRICT_DISABLE=true
                shift
                ;;
            --json)
                AUDIT_JSON=true
                shift
                ;;
            --csv)
                EXPORT_CSV=true
                shift
                ;;
            --apply)
                FIX_APPLY=true
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                msg_error "Unknown option: $1"
                msg_info "Run 'mcp --help' for usage information"
                exit 1
                ;;
            enable|disable)
                CMD_MODE="$1"
                shift
                CMD_ALL=false
                CMD_SERVERS=()
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --all) CMD_ALL=true; shift ;;
                        --json) AUDIT_JSON=true; shift ;;
                        --quiet|-q) QUIET_MODE=true; shift ;;
                        --) shift; break ;;
                        -*) msg_error "Unknown option: $1"; exit 1 ;;
                        *) CMD_SERVERS+=("$1"); shift ;;
                    esac
                done
                return 0
                ;;
            *)
                break
                ;;
        esac
    done

    # Remaining args are passed to Claude
    CLAUDE_ARGS=("$@")
}

# ============================================================================
# AUDIT COMMAND IMPLEMENTATION
# ============================================================================

# Audit: Check if control arrays are in correct locations
# Returns: Array of issues found
audit_control_array_placement() {
    local issues=()

    # Check for disabledMcpServers in settings files (WRONG location)
    local settings_files=(
        "./.claude/settings.local.json"
        "./.claude/settings.json"
        "$HOME/.claude/settings.json"
        "$HOME/.claude/settings.local.json"
    )

    for file in "${settings_files[@]}"; do
        if [[ -f "$file" ]] && jq -e '.disabledMcpServers' "$file" &>/dev/null; then
            issues+=("ERROR:disabledMcpServers in wrong location:$file:Should be in ~/.claude.json only")
        fi
    done

    # Check for enabledMcpjsonServers/disabledMcpjsonServers in ~/.claude.json (WRONG location)
    if [[ -f "$HOME/.claude.json" ]]; then
        if jq -e '.enabledMcpjsonServers' "$HOME/.claude.json" &>/dev/null; then
            issues+=("ERROR:enabledMcpjsonServers in wrong location:$HOME/.claude.json:Should be in .claude/settings*.json files")
        fi
        if jq -e '.disabledMcpjsonServers' "$HOME/.claude.json" &>/dev/null; then
            issues+=("ERROR:disabledMcpjsonServers in wrong location:$HOME/.claude.json:Should be in .claude/settings*.json files")
        fi
    fi

    printf '%s\n' "${issues[@]}"
}

# Audit: Check for duplicate server definitions
audit_definition_conflicts() {
    local issues=()
    local raw_data
    raw_data=$(discover_and_parse_all_sources 2>/dev/null || true)

    # Build map of server -> locations
    declare -A server_locations
    while IFS=: read -r type server scope file _; do
        [[ "$type" != "def" ]] && continue
        [[ -z "$server" ]] && continue

        if [[ -n "${server_locations[$server]:-}" ]]; then
            server_locations[$server]+=" AND $scope:$file"
        else
            server_locations[$server]="$scope:$file"
        fi
    done <<< "$raw_data"

    # Find duplicates
    for server in "${!server_locations[@]}"; do
        if [[ "${server_locations[$server]}" == *" AND "* ]]; then
            issues+=("WARNING:Server '$server' defined in multiple locations:${server_locations[$server]}:Higher priority wins")
        fi
    done

    printf '%s\n' "${issues[@]}"
}

# Audit: Check for orphaned references
audit_orphaned_references() {
    local issues=()
    local raw_data
    raw_data=$(discover_and_parse_all_sources 2>/dev/null || true)

    # Collect all defined servers
    declare -A defined_servers
    while IFS=: read -r type server _ _ _; do
        [[ "$type" == "def" ]] && defined_servers[$server]=1
    done <<< "$raw_data"

    # Check enabled/disabled references
    while IFS=: read -r type server scope file; do
        [[ "$type" != "enable" && "$type" != "disable" ]] && continue
        [[ -z "$server" ]] && continue

        if [[ -z "${defined_servers[$server]:-}" ]]; then
            issues+=("INFO:Orphaned reference '$server' in $type list:$file:Server not defined anywhere")
        fi
    done <<< "$raw_data"

    printf '%s\n' "${issues[@]}"
}

# Audit: Check for plugin control issues
audit_plugin_issues() {
    local issues=()
    local settings_files=(
        "./.claude/settings.local.json"
        "./.claude/settings.json"
        "$HOME/.claude/settings.json"
        "$HOME/.claude/settings.local.json"
    )

    for file in "${settings_files[@]}"; do
        if [[ -f "$file" ]]; then
            # Find plugins explicitly set to false
            local false_plugins
            false_plugins=$(jq -r '.enabledPlugins // {} | to_entries[] | select(.value == false) | .key' "$file" 2>/dev/null || true)

            while IFS= read -r plugin; do
                [[ -z "$plugin" ]] && continue
                issues+=("WARNING:Plugin '$plugin' set to explicit false:$file:Plugin will be hidden from Claude UI")
            done <<< "$false_plugins"
        fi
    done

    printf '%s\n' "${issues[@]}"
}

# Audit: Check plugin MCP server discovery issues
audit_plugin_mcp_discovery() {
    local issues=()
    local marketplace_dir="$HOME/.claude/plugins/marketplaces"

    if [[ ! -d "$marketplace_dir" ]]; then
        # No marketplaces installed, nothing to audit
        printf '%s\n' "${issues[@]}"
        return 0
    fi

    # Find all marketplace.json files
    while IFS= read -r marketplace_file; do
        [[ ! -f "$marketplace_file" ]] && continue

        # Validate marketplace.json
        if ! jq empty "$marketplace_file" 2>/dev/null; then
            issues+=("ERROR:Invalid marketplace JSON:$marketplace_file:Marketplace configuration cannot be parsed")
            continue
        fi

        # Get marketplace base directory
        local marketplace_base
        marketplace_base=$(dirname "$marketplace_file")
        marketplace_base=$(dirname "$marketplace_base")
        local marketplace_name
        marketplace_name=$(basename "$marketplace_base")

        # Check each plugin's .mcp.json file
        while IFS=: read -r plugin_name plugin_source; do
            [[ -z "$plugin_name" ]] || [[ -z "$plugin_source" ]] && continue

            # Security: Skip plugins with unsafe paths
            if [[ "$plugin_source" =~ \.\. ]] || [[ "$plugin_source" =~ ^/ ]]; then
                issues+=("WARNING:Plugin with unsafe path:$plugin_name ($plugin_source):Path traversal detected")
                continue
            fi

            local mcp_file="${marketplace_base}/${plugin_source}/.mcp.json"

            # Only audit if .mcp.json exists
            if [[ -f "$mcp_file" ]]; then
                # Check JSON validity
                if ! jq empty "$mcp_file" 2>/dev/null; then
                    issues+=("ERROR:Invalid plugin .mcp.json:$mcp_file:Plugin MCP configuration cannot be parsed")
                    continue
                fi

                # Check for mcpServers object
                local has_servers
                has_servers=$(jq -r 'has("mcpServers")' "$mcp_file" 2>/dev/null)
                if [[ "$has_servers" != "true" ]]; then
                    issues+=("INFO:.mcp.json missing mcpServers:$mcp_file:File exists but has no mcpServers object")
                fi
            fi
        done < <(jq -r '.plugins[]? | "\(.name):\(.source)"' "$marketplace_file" 2>/dev/null || true)
    done < <(find "$marketplace_dir" -path "*/.claude-plugin/marketplace.json" -type f 2>/dev/null)

    printf '%s\n' "${issues[@]}"
}

# Audit: Check JSON syntax in all config files
audit_json_syntax() {
    local issues=()
    local config_files=(
        "$HOME/.claude.json"
        "$HOME/.mcp.json"
        "$HOME/.claude/settings.json"
        "$HOME/.claude/settings.local.json"
        "./.mcp.json"
        "./.claude/settings.json"
        "./.claude/settings.local.json"
    )

    for file in "${config_files[@]}"; do
        if [[ -f "$file" ]]; then
            if ! jq empty "$file" 2>/dev/null; then
                issues+=("ERROR:Invalid JSON syntax:$file:File cannot be parsed")
            fi
        fi
    done

    printf '%s\n' "${issues[@]}"
}

# Run full audit and display results
run_audit() {
    local all_issues=()
    local error_count=0
    local warning_count=0
    local info_count=0

    # Collect all issues
    while IFS= read -r issue; do
        [[ -z "$issue" ]] && continue
        all_issues+=("$issue")
        case "$issue" in
            ERROR:*) ((error_count++)) ;;
            WARNING:*) ((warning_count++)) ;;
            INFO:*) ((info_count++)) ;;
        esac
    done < <(audit_json_syntax; audit_control_array_placement; audit_definition_conflicts; audit_orphaned_references; audit_plugin_issues; audit_plugin_mcp_discovery)

    if [[ "$AUDIT_JSON" == "true" ]]; then
        # JSON output
        local json_issues="["
        local first=true
        for issue in "${all_issues[@]}"; do
            IFS=: read -r severity type location details <<< "$issue"
            [[ "$first" != "true" ]] && json_issues+=","
            first=false
            json_issues+="{\"severity\":\"$severity\",\"type\":\"$type\",\"location\":\"$location\",\"details\":\"$details\"}"
        done
        json_issues+="]"

        jq -n --argjson issues "$json_issues" \
              --argjson errors "$error_count" \
              --argjson warnings "$warning_count" \
              --argjson info "$info_count" \
            '{summary: {errors: $errors, warnings: $warnings, info: $info}, issues: $issues}'
    else
        # Human-readable output
        echo ""
        echo -e "${COLOR_WHITE}╔════════════════════════════════════════════════════════════╗${COLOR_RESET}"
        echo -e "${COLOR_WHITE}║${COLOR_RESET}              ${COLOR_CYAN}MCP Configuration Audit Report${COLOR_RESET}              ${COLOR_WHITE}║${COLOR_RESET}"
        echo -e "${COLOR_WHITE}╚════════════════════════════════════════════════════════════╝${COLOR_RESET}"
        echo ""

        if [[ ${#all_issues[@]} -eq 0 ]]; then
            echo -e "${COLOR_GREEN}${MARK_SUCCESS} Configuration Health: ALL CHECKS PASSED${COLOR_RESET}"
            echo ""
            echo -e "  No issues detected in your MCP configuration."
            echo ""
        else
            if [[ $error_count -gt 0 ]]; then
                echo -e "${COLOR_RED}${MARK_ERROR} Configuration Health: ERRORS FOUND${COLOR_RESET}"
            else
                echo -e "${COLOR_YELLOW}${MARK_WARNING} Configuration Health: WARNINGS FOUND${COLOR_RESET}"
            fi
            echo ""

            # Group by type
            local current_type=""
            for issue in "${all_issues[@]}"; do
                IFS=: read -r severity type location details <<< "$issue"

                if [[ "$type" != "$current_type" ]]; then
                    current_type="$type"
                    echo -e "  ${COLOR_WHITE}═══ $type ═══${COLOR_RESET}"
                fi

                case "$severity" in
                    ERROR)   echo -e "  ${COLOR_RED}${MARK_ERROR}${COLOR_RESET} $location" ;;
                    WARNING) echo -e "  ${COLOR_YELLOW}${MARK_WARNING}${COLOR_RESET} $location" ;;
                    INFO)    echo -e "  ${COLOR_CYAN}${MARK_INFO}${COLOR_RESET} $location" ;;
                esac
                echo -e "     ${COLOR_GREY}$details${COLOR_RESET}"
                echo ""
            done
        fi

        echo -e "${COLOR_WHITE}═══ Summary ═══${COLOR_RESET}"
        echo -e "  Errors:   $error_count"
        echo -e "  Warnings: $warning_count"
        echo -e "  Info:     $info_count"
        echo ""

        if [[ $error_count -gt 0 || $warning_count -gt 0 ]]; then
            echo -e "${COLOR_CYAN}Run './mcp --fix-config' to repair issues${COLOR_RESET}"
            echo ""
        fi
    fi

    # Exit with error if errors found
    [[ $error_count -gt 0 ]] && return 1
    return 0
}

# ============================================================================
# VALIDATE COMMAND IMPLEMENTATION
# ============================================================================

# Quick validation - just check JSON syntax and basic structure
run_validate() {
    local has_errors=false

    echo -e "${COLOR_CYAN}Validating MCP configuration files...${COLOR_RESET}"
    echo ""

    local config_files=(
        "$HOME/.claude.json:User config"
        "$HOME/.mcp.json:User MCP"
        "$HOME/.claude/settings.json:User settings"
        "$HOME/.claude/settings.local.json:User local settings"
        "./.mcp.json:Project MCP"
        "./.claude/settings.json:Project settings"
        "./.claude/settings.local.json:Project local settings"
    )

    for entry in "${config_files[@]}"; do
        IFS=: read -r file label <<< "$entry"

        if [[ -f "$file" ]]; then
            if jq empty "$file" 2>/dev/null; then
                echo -e "  ${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $label ($file)"
            else
                echo -e "  ${COLOR_RED}${MARK_ERROR}${COLOR_RESET} $label ($file) - Invalid JSON"
                has_errors=true
            fi
        else
            echo -e "  ${COLOR_GREY}○${COLOR_RESET} $label ($file) - Not found"
        fi
    done

    echo ""

    if [[ "$has_errors" == "true" ]]; then
        echo -e "${COLOR_RED}Validation FAILED - Fix JSON syntax errors${COLOR_RESET}"
        return 1
    else
        echo -e "${COLOR_GREEN}Validation PASSED${COLOR_RESET}"
        return 0
    fi
}

# ============================================================================
# DEBUG-PRECEDENCE COMMAND IMPLEMENTATION
# ============================================================================

# Show detailed precedence resolution for a specific server
run_debug_precedence() {
    local target_server="$1"
    local raw_data
    raw_data=$(discover_and_parse_all_sources 2>/dev/null || true)

    echo ""
    echo -e "${COLOR_WHITE}╔════════════════════════════════════════════════════════════╗${COLOR_RESET}"
    echo -e "${COLOR_WHITE}║${COLOR_RESET}           ${COLOR_CYAN}Precedence Resolution: $target_server${COLOR_RESET}"
    echo -e "${COLOR_WHITE}╚════════════════════════════════════════════════════════════╝${COLOR_RESET}"
    echo ""

    # Collect definitions
    local def_found=false
    echo -e "${COLOR_WHITE}═══ Definition Resolution ═══${COLOR_RESET}"

    declare -A definitions
    while IFS=: read -r type server scope file source_type; do
        [[ "$type" != "def" ]] && continue
        [[ "$server" != "$target_server" ]] && continue

        def_found=true
        local priority
        priority=$(get_scope_priority "$scope")
        definitions["$priority:$scope"]="$file ($source_type)"
    done <<< "$raw_data"

    if [[ "$def_found" == "false" ]]; then
        echo -e "  ${COLOR_RED}${MARK_ERROR} Server '$target_server' not found in any configuration${COLOR_RESET}"
        echo ""
        return 1
    fi

    # Show definitions in priority order (highest first)
    local winning_def=""
    local winning_priority=0
    for key in $(echo "${!definitions[@]}" | tr ' ' '\n' | sort -t: -k1 -rn); do
        IFS=: read -r priority scope <<< "$key"
        local file="${definitions[$key]}"

        if [[ $priority -gt $winning_priority ]]; then
            winning_priority=$priority
            winning_def="$file"
            echo -e "  ${COLOR_GREEN}Priority $priority ($scope):${COLOR_RESET} $file ${COLOR_GREEN}← ACTIVE${COLOR_RESET}"
        else
            echo -e "  ${COLOR_GREY}Priority $priority ($scope): $file (shadowed)${COLOR_RESET}"
        fi
    done
    echo ""

    # Collect state
    echo -e "${COLOR_WHITE}═══ State Resolution ═══${COLOR_RESET}"

    declare -A states
    local state_found=false
    while IFS=: read -r type server scope file; do
        [[ "$type" != "enable" && "$type" != "disable" ]] && continue
        [[ "$server" != "$target_server" ]] && continue

        state_found=true
        local priority
        priority=$(get_scope_priority "$scope")
        states["$priority:$scope:$type"]="$file"
    done <<< "$raw_data"

    if [[ "$state_found" == "false" ]]; then
        echo -e "  ${COLOR_GREY}No explicit enable/disable found${COLOR_RESET}"
        echo -e "  ${COLOR_GREEN}Default: ENABLED${COLOR_RESET}"
    else
        local winning_state=""
        local winning_state_priority=0
        for key in $(echo "${!states[@]}" | tr ' ' '\n' | sort -t: -k1 -rn); do
            IFS=: read -r priority scope type <<< "$key"
            local file="${states[$key]}"

            if [[ $priority -gt $winning_state_priority ]]; then
                winning_state_priority=$priority
                winning_state="$type"
                local color="${COLOR_GREEN}"
                [[ "$type" == "disable" ]] && color="${COLOR_RED}"
                echo -e "  ${color}Priority $priority ($scope): $type in $file ← ACTIVE${COLOR_RESET}"
            else
                echo -e "  ${COLOR_GREY}Priority $priority ($scope): $type in $file (overridden)${COLOR_RESET}"
            fi
        done
    fi
    echo ""

    # Check runtime override (disabledMcpServers in ~/.claude.json)
    echo -e "${COLOR_WHITE}═══ Runtime Override Check ═══${COLOR_RESET}"

    local cwd
    cwd=$(pwd)
    local runtime_disabled=false

    if [[ -f "$HOME/.claude.json" ]]; then
        local disabled_list
        disabled_list=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers // [] | .[]' "$HOME/.claude.json" 2>/dev/null || true)

        while IFS= read -r disabled_server; do
            if [[ "$disabled_server" == "$target_server" ]]; then
                runtime_disabled=true
                break
            fi
        done <<< "$disabled_list"
    fi

    if [[ "$runtime_disabled" == "true" ]]; then
        echo -e "  ${COLOR_ORANGE}● RUNTIME DISABLED${COLOR_RESET}"
        echo -e "  ${COLOR_GREY}Listed in ~/.claude.json .projects[$cwd].disabledMcpServers${COLOR_RESET}"
        echo -e "  ${COLOR_GREY}Server is configured but won't start (ORANGE state)${COLOR_RESET}"
    else
        echo -e "  ${COLOR_GREY}No runtime override found${COLOR_RESET}"
    fi
    echo ""

    # Final result
    echo -e "${COLOR_WHITE}═══ Final State ═══${COLOR_RESET}"
    local final_state="ENABLED"
    local final_color="${COLOR_GREEN}"

    if [[ "${winning_state:-enable}" == "disable" ]]; then
        final_state="DISABLED"
        final_color="${COLOR_RED}"
    elif [[ "$runtime_disabled" == "true" ]]; then
        final_state="RUNTIME DISABLED (ORANGE)"
        final_color="${COLOR_ORANGE}"
    fi

    echo -e "  ${final_color}● $final_state${COLOR_RESET}"
    echo ""
}

# ============================================================================
# FIX-CONFIG COMMAND IMPLEMENTATION
# ============================================================================

# Fix configuration issues
run_fix_config() {
    local issues=()
    local fixed_count=0

    echo ""
    echo -e "${COLOR_WHITE}╔════════════════════════════════════════════════════════════╗${COLOR_RESET}"
    echo -e "${COLOR_WHITE}║${COLOR_RESET}              ${COLOR_CYAN}MCP Configuration Repair${COLOR_RESET}                    ${COLOR_WHITE}║${COLOR_RESET}"
    echo -e "${COLOR_WHITE}╚════════════════════════════════════════════════════════════╝${COLOR_RESET}"
    echo ""

    # Collect fixable issues
    while IFS= read -r issue; do
        [[ -z "$issue" ]] && continue
        [[ "$issue" != ERROR:* && "$issue" != WARNING:* ]] && continue
        issues+=("$issue")
    done < <(audit_control_array_placement; audit_plugin_issues)

    if [[ ${#issues[@]} -eq 0 ]]; then
        echo -e "${COLOR_GREEN}${MARK_SUCCESS} No fixable issues found${COLOR_RESET}"
        echo ""
        return 0
    fi

    echo -e "Found ${#issues[@]} fixable issue(s):"
    echo ""

    for issue in "${issues[@]}"; do
        IFS=: read -r severity type location details <<< "$issue"

        echo -e "  ${COLOR_YELLOW}${MARK_WARNING}${COLOR_RESET} $type"
        echo -e "     Location: $location"
        echo -e "     Issue: $details"
        echo ""

        local do_fix=false
        if [[ "$FIX_APPLY" == "true" ]]; then
            do_fix=true
        else
            echo -n "  Fix this issue? [y/N] "
            read -r response
            [[ "$response" =~ ^[Yy] ]] && do_fix=true
        fi

        if [[ "$do_fix" == "true" ]]; then
            case "$type" in
                "disabledMcpServers in wrong location")
                    # Move disabledMcpServers from settings file to ~/.claude.json
                    if fix_move_disabled_mcp_servers "$location"; then
                        echo -e "  ${COLOR_GREEN}${MARK_SUCCESS} Fixed${COLOR_RESET}"
                        ((fixed_count++))
                    else
                        echo -e "  ${COLOR_RED}${MARK_ERROR} Failed to fix${COLOR_RESET}"
                    fi
                    ;;
                "Plugin '*' set to explicit false")
                    # Remove explicit false from enabledPlugins
                    local plugin_name
                    plugin_name=$(echo "$type" | sed "s/Plugin '\([^']*\)'.*/\1/")
                    if fix_remove_plugin_false "$location" "$plugin_name"; then
                        echo -e "  ${COLOR_GREEN}${MARK_SUCCESS} Fixed${COLOR_RESET}"
                        ((fixed_count++))
                    else
                        echo -e "  ${COLOR_RED}${MARK_ERROR} Failed to fix${COLOR_RESET}"
                    fi
                    ;;
                *)
                    echo -e "  ${COLOR_GREY}Auto-fix not available for this issue${COLOR_RESET}"
                    ;;
            esac
        else
            echo -e "  ${COLOR_GREY}Skipped${COLOR_RESET}"
        fi
        echo ""
    done

    echo -e "${COLOR_WHITE}═══ Summary ═══${COLOR_RESET}"
    echo -e "  Fixed: $fixed_count / ${#issues[@]} issues"
    echo ""
}

# Fix helper: Move disabledMcpServers from settings file to ~/.claude.json
fix_move_disabled_mcp_servers() {
    local source_file="$1"
    local cwd
    cwd=$(pwd)

    # Extract the array from source
    local servers
    servers=$(jq -r '.disabledMcpServers // [] | .[]' "$source_file" 2>/dev/null || true)

    [[ -z "$servers" ]] && return 0  # Nothing to move

    # Create backup
    mkdir -p "$BACKUP_DIR"
    cp "$source_file" "$BACKUP_DIR/$(basename "$source_file").backup.$(date +%s)"

    # Remove from source file
    local temp_file
    temp_file=$(mktemp)
    jq 'del(.disabledMcpServers)' "$source_file" > "$temp_file"
    mv "$temp_file" "$source_file"

    # Add to ~/.claude.json .projects[cwd].disabledMcpServers
    if [[ -f "$HOME/.claude.json" ]]; then
        cp "$HOME/.claude.json" "$BACKUP_DIR/claude.json.backup.$(date +%s)"

        temp_file=$(mktemp)
        local servers_json
        servers_json=$(echo "$servers" | jq -R -s 'split("\n") | map(select(. != ""))')

        jq --arg cwd "$cwd" --argjson servers "$servers_json" '
            .projects //= {} |
            .projects[$cwd] //= {} |
            .projects[$cwd].disabledMcpServers = ((.projects[$cwd].disabledMcpServers // []) + $servers | unique)
        ' "$HOME/.claude.json" > "$temp_file"

        mv "$temp_file" "$HOME/.claude.json"
    fi

    return 0
}

# Fix helper: Remove explicit false from enabledPlugins
fix_remove_plugin_false() {
    local file="$1"
    local plugin="$2"

    # Create backup
    mkdir -p "$BACKUP_DIR"
    cp "$file" "$BACKUP_DIR/$(basename "$file").backup.$(date +%s)"

    # Remove the plugin from enabledPlugins
    local temp_file
    temp_file=$(mktemp)
    jq --arg plugin "$plugin" 'del(.enabledPlugins[$plugin])' "$file" > "$temp_file"
    mv "$temp_file" "$file"

    return 0
}

# ============================================================================
# RESTORE-PLUGIN COMMAND IMPLEMENTATION
# ============================================================================

# Restore a hard-disabled plugin
run_restore_plugin() {
    local plugin_name="$1"

    echo ""
    echo -e "${COLOR_CYAN}Restoring plugin: $plugin_name${COLOR_RESET}"
    echo ""

    local found=false
    local settings_files=(
        "./.claude/settings.local.json"
        "./.claude/settings.json"
        "$HOME/.claude/settings.json"
        "$HOME/.claude/settings.local.json"
    )

    for file in "${settings_files[@]}"; do
        if [[ -f "$file" ]]; then
            local is_false
            is_false=$(jq -r --arg plugin "$plugin_name" '.enabledPlugins[$plugin] // "null"' "$file" 2>/dev/null || echo "null")

            if [[ "$is_false" == "false" ]]; then
                found=true
                echo -e "  Found in: $file"

                # Create backup
                mkdir -p "$BACKUP_DIR"
                cp "$file" "$BACKUP_DIR/$(basename "$file").backup.$(date +%s)"

                # Remove the explicit false
                local temp_file
                temp_file=$(mktemp)
                jq --arg plugin "$plugin_name" 'del(.enabledPlugins[$plugin])' "$file" > "$temp_file"
                mv "$temp_file" "$file"

                echo -e "  ${COLOR_GREEN}${MARK_SUCCESS} Removed explicit false - plugin will now be visible${COLOR_RESET}"
            fi
        fi
    done

    if [[ "$found" == "false" ]]; then
        echo -e "  ${COLOR_YELLOW}${MARK_WARNING} Plugin '$plugin_name' not found in any enabledPlugins with false value${COLOR_RESET}"
        echo ""
        echo -e "  Possible reasons:"
        echo -e "  - Plugin name may be incorrect (format: name@marketplace)"
        echo -e "  - Plugin may already be enabled or never hard-disabled"
        return 1
    fi

    echo ""
    echo -e "${COLOR_GREEN}Plugin restored. It should now appear in Claude.${COLOR_RESET}"
    echo ""
}

# ============================================================================
# ROLLBACK COMMAND IMPLEMENTATION
# ============================================================================

# Show available backups and allow restoring one
run_rollback() {
    echo ""
    echo -e "${COLOR_WHITE}╔════════════════════════════════════════════════════════════╗${COLOR_RESET}"
    echo -e "${COLOR_WHITE}║${COLOR_RESET}              ${COLOR_CYAN}Configuration Rollback${COLOR_RESET}                       ${COLOR_WHITE}║${COLOR_RESET}"
    echo -e "${COLOR_WHITE}╚════════════════════════════════════════════════════════════╝${COLOR_RESET}"
    echo ""

    # Check if backup directory exists
    if [[ ! -d "$BACKUP_DIR" ]]; then
        echo -e "${COLOR_YELLOW}${MARK_WARNING} No backups found${COLOR_RESET}"
        echo ""
        echo -e "  Backups are created automatically when you modify configuration."
        echo -e "  Backup location: $BACKUP_DIR"
        echo ""
        return 0
    fi

    # List available backups
    local backups=()
    while IFS= read -r -d '' file; do
        backups+=("$file")
    done < <(find "$BACKUP_DIR" -type f -name "*.backup.*" -print0 2>/dev/null | sort -z -r)

    if [[ ${#backups[@]} -eq 0 ]]; then
        echo -e "${COLOR_YELLOW}${MARK_WARNING} No backups found in $BACKUP_DIR${COLOR_RESET}"
        echo ""
        return 0
    fi

    echo -e "Available backups (most recent first):"
    echo ""

    local idx=1
    for backup in "${backups[@]}"; do
        local filename=$(basename "$backup")
        local timestamp=$(echo "$filename" | grep -oE '[0-9]{10}$' || echo "unknown")
        local date_str=""

        if [[ "$timestamp" != "unknown" ]]; then
            date_str=$(date -d "@$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || date -r "$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "unknown")
        fi

        # Get original file name
        local original=$(echo "$filename" | sed 's/\.backup\.[0-9]*$//')

        echo -e "  ${COLOR_CYAN}[$idx]${COLOR_RESET} $original"
        echo -e "      ${COLOR_GREY}Backed up: $date_str${COLOR_RESET}"
        echo -e "      ${COLOR_GREY}File: $backup${COLOR_RESET}"
        echo ""

        ((idx++))

        # Limit to 10 most recent
        [[ $idx -gt 10 ]] && break
    done

    echo -n "Enter number to restore (or 'q' to quit): "
    read -r choice

    if [[ "$choice" == "q" || "$choice" == "Q" || -z "$choice" ]]; then
        echo -e "${COLOR_GREY}Cancelled${COLOR_RESET}"
        return 0
    fi

    # Validate choice
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 ]] || [[ "$choice" -gt ${#backups[@]} ]]; then
        echo -e "${COLOR_RED}${MARK_ERROR} Invalid selection${COLOR_RESET}"
        return 1
    fi

    local selected_backup="${backups[$((choice - 1))]}"
    local original_file=$(basename "$selected_backup" | sed 's/\.backup\.[0-9]*$//')

    # Determine target path
    local target_path=""
    case "$original_file" in
        claude.json)
            target_path="$HOME/.claude.json"
            ;;
        settings.json)
            target_path="./.claude/settings.json"
            ;;
        settings.local.json)
            target_path="./.claude/settings.local.json"
            ;;
        *)
            echo -e "${COLOR_YELLOW}${MARK_WARNING} Unknown backup type: $original_file${COLOR_RESET}"
            echo -n "Enter target path to restore to: "
            read -r target_path
            ;;
    esac

    if [[ -z "$target_path" ]]; then
        echo -e "${COLOR_RED}${MARK_ERROR} No target path specified${COLOR_RESET}"
        return 1
    fi

    echo ""
    echo -e "Restore ${COLOR_CYAN}$selected_backup${COLOR_RESET}"
    echo -e "     to ${COLOR_CYAN}$target_path${COLOR_RESET}"
    echo ""
    echo -n "Confirm? [y/N] "
    read -r confirm

    if [[ ! "$confirm" =~ ^[Yy] ]]; then
        echo -e "${COLOR_GREY}Cancelled${COLOR_RESET}"
        return 0
    fi

    # Create backup of current file before restore
    if [[ -f "$target_path" ]]; then
        local current_backup="$BACKUP_DIR/$(basename "$target_path").pre-rollback.$(date +%s)"
        cp "$target_path" "$current_backup"
        echo -e "${COLOR_CYAN}${MARK_INFO} Current file backed up to: $current_backup${COLOR_RESET}"
    fi

    # Restore
    mkdir -p "$(dirname "$target_path")"
    cp "$selected_backup" "$target_path"

    # Validate restored file
    if jq empty "$target_path" 2>/dev/null; then
        echo -e "${COLOR_GREEN}${MARK_SUCCESS} Restored successfully${COLOR_RESET}"
    else
        echo -e "${COLOR_RED}${MARK_ERROR} Warning: Restored file may have invalid JSON${COLOR_RESET}"
    fi

    echo ""
}

# ============================================================================
# EXPORT-DISABLED COMMAND IMPLEMENTATION
# ============================================================================

# Export list of disabled servers (for hook automation)
run_export_disabled() {
    # Need to discover and load servers first
    discover_settings_file
    load_servers

    # Build arrays with full info for CSV support
    local -a disabled_servers=()
    local -a disabled_types=()
    local -a orange_servers=()
    local -a orange_types=()

    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^# ]] && continue

        local state=$(echo "$line" | cut -d: -f1)
        local server=$(echo "$line" | cut -d: -f2)
        local source_type=$(echo "$line" | cut -d: -f5)
        local runtime=$(echo "$line" | cut -d: -f7)

        if [[ "$state" == "off" ]]; then
            disabled_servers+=("$server")
            disabled_types+=("$source_type")
        elif [[ "$state" == "on" && "$runtime" == "stopped" ]]; then
            orange_servers+=("$server")
            orange_types+=("$source_type")
        fi
    done < "$STATE_FILE"

    if [[ "$EXPORT_CSV" == true ]]; then
        # CSV output with headers
        echo "server,state,type"
        for i in "${!disabled_servers[@]}"; do
            echo "${disabled_servers[$i]},disabled,${disabled_types[$i]}"
        done
        for i in "${!orange_servers[@]}"; do
            echo "${orange_servers[$i]},orange,${orange_types[$i]}"
        done
    elif [[ "$AUDIT_JSON" == true ]]; then
        # JSON output
        local json_disabled=$(printf '%s\n' "${disabled_servers[@]}" | jq -R . | jq -s .)
        local json_orange=$(printf '%s\n' "${orange_servers[@]}" | jq -R . | jq -s .)
        jq -n --argjson disabled "$json_disabled" --argjson orange "$json_orange" \
            '{disabled: $disabled, orange: $orange}'
    else
        # Simple comma-separated output
        if [[ "$QUIET_MODE" != true ]]; then
            echo "# Disabled (RED):"
        fi
        if [[ ${#disabled_servers[@]} -gt 0 ]]; then
            IFS=','; echo "${disabled_servers[*]}"; unset IFS
        fi

        if [[ "$QUIET_MODE" != true ]]; then
            echo "# Runtime-disabled (ORANGE):"
        fi
        if [[ ${#orange_servers[@]} -gt 0 ]]; then
            IFS=','; echo "${orange_servers[*]}"; unset IFS
        fi
    fi
}

# ============================================================================
# SYNC-CHECK COMMAND IMPLEMENTATION
# ============================================================================

# Compare config state vs runtime state
run_sync_check() {
    # Need to discover and load servers first
    discover_settings_file
    load_servers

    echo ""
    echo -e "${COLOR_WHITE}╔════════════════════════════════════════════════════════════╗${COLOR_RESET}"
    echo -e "${COLOR_WHITE}║${COLOR_RESET}              ${COLOR_CYAN}Config vs Runtime Sync Check${COLOR_RESET}                 ${COLOR_WHITE}║${COLOR_RESET}"
    echo -e "${COLOR_WHITE}╚════════════════════════════════════════════════════════════╝${COLOR_RESET}"
    echo ""

    # Check if Claude is available
    local claude_bin
    claude_bin=$(command -v claude 2>/dev/null)
    if [[ -z "$claude_bin" ]]; then
        echo -e "${COLOR_YELLOW}${MARK_WARNING} Claude CLI not found - cannot check runtime state${COLOR_RESET}"
        echo ""
        return 1
    fi

    # Get runtime state from claude mcp list
    local runtime_output
    runtime_output=$("$claude_bin" mcp list 2>/dev/null)
    local runtime_exit=$?

    if [[ $runtime_exit -ne 0 ]]; then
        echo -e "${COLOR_YELLOW}${MARK_WARNING} Could not get runtime state (claude mcp list failed)${COLOR_RESET}"
        echo ""
        return 1
    fi

    # Parse runtime output for connected/disconnected servers
    declare -A runtime_state
    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*([a-zA-Z0-9_-]+):[[:space:]]*(connected|disconnected|error) ]]; then
            local srv="${BASH_REMATCH[1]}"
            local status="${BASH_REMATCH[2]}"
            if [[ "$status" == "connected" ]]; then
                runtime_state["$srv"]="running"
            else
                runtime_state["$srv"]="stopped"
            fi
        fi
    done <<< "$runtime_output"

    # Compare with config state
    printf "%-25s %-12s %-12s %s\n" "Server" "Config" "Runtime" "Status"
    printf "%-25s %-12s %-12s %s\n" "─────────────────────────" "────────────" "────────────" "──────────────"

    local sync_issues=0
    # Track issues for detailed output
    declare -a issue_servers=()
    declare -a issue_configs=()
    declare -a issue_runtimes=()
    declare -a issue_types=()

    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^# ]] && continue

        local state=$(echo "$line" | cut -d: -f1)
        local server=$(echo "$line" | cut -d: -f2)
        local source_type=$(echo "$line" | cut -d: -f5)
        local runtime=$(echo "$line" | cut -d: -f7)

        # Config state
        local config_state="enabled"
        [[ "$state" == "off" ]] && config_state="disabled"
        [[ "$runtime" == "stopped" ]] && config_state="orange"

        # Runtime state (from claude mcp list)
        local actual_runtime="${runtime_state[$server]:-unknown}"

        # Determine sync status
        local sync_status="${COLOR_GREEN}${MARK_SUCCESS} in sync${COLOR_RESET}"

        if [[ "$config_state" == "enabled" && "$actual_runtime" == "stopped" ]]; then
            sync_status="${COLOR_YELLOW}! config:on, runtime:off${COLOR_RESET}"
            ((sync_issues++))
            issue_servers+=("$server")
            issue_configs+=("$config_state")
            issue_runtimes+=("$actual_runtime")
            issue_types+=("config_on_runtime_off:$source_type")
        elif [[ "$config_state" == "disabled" && "$actual_runtime" == "running" ]]; then
            sync_status="${COLOR_RED}! BUG #13311${COLOR_RESET}"
            ((sync_issues++))
            issue_servers+=("$server")
            issue_configs+=("$config_state")
            issue_runtimes+=("$actual_runtime")
            issue_types+=("disabled_but_running:$source_type")
        elif [[ "$config_state" == "orange" && "$actual_runtime" == "running" ]]; then
            sync_status="${COLOR_RED}! BUG #13311${COLOR_RESET}"
            ((sync_issues++))
            issue_servers+=("$server")
            issue_configs+=("$config_state")
            issue_runtimes+=("$actual_runtime")
            issue_types+=("orange_but_running:$source_type")
        elif [[ "$actual_runtime" == "unknown" ]]; then
            sync_status="${COLOR_GREY}? not in runtime${COLOR_RESET}"
        fi

        printf "%-25s %-12s %-12s %b\n" "$server" "$config_state" "$actual_runtime" "$sync_status"
    done < "$STATE_FILE"

    echo ""
    if [[ $sync_issues -gt 0 ]]; then
        echo -e "${COLOR_WHITE}══════════════════════════════════════════════════════════════${COLOR_RESET}"
        echo -e "${COLOR_RED}ISSUES REQUIRING ATTENTION (${sync_issues})${COLOR_RESET}"
        echo -e "${COLOR_WHITE}══════════════════════════════════════════════════════════════${COLOR_RESET}"
        echo ""

        for i in "${!issue_servers[@]}"; do
            local server="${issue_servers[$i]}"
            local config="${issue_configs[$i]}"
            local runtime="${issue_runtimes[$i]}"
            local type_info="${issue_types[$i]}"
            local issue_type="${type_info%%:*}"
            local source_type="${type_info##*:}"

            if [[ "$issue_type" == "disabled_but_running" ]]; then
                echo -e "${COLOR_RED}[HIGH]${COLOR_RESET} ${COLOR_WHITE}${server}${COLOR_RESET}: Server running despite being disabled in config"
                echo -e "  ${COLOR_GREY}Bug: #13311 - disabledMcpServers not enforced at session start${COLOR_RESET}"
                echo -e "  ${COLOR_CYAN}Fix:${COLOR_RESET} Run '${COLOR_WHITE}mcp --strict-disable${COLOR_RESET}' before launching Claude"
                if [[ "$source_type" == "mcpjson" ]]; then
                    echo -e "       OR add to ${COLOR_WHITE}disabledMcpjsonServers${COLOR_RESET} in settings"
                fi
                echo ""
            elif [[ "$issue_type" == "orange_but_running" ]]; then
                echo -e "${COLOR_RED}[HIGH]${COLOR_RESET} ${COLOR_WHITE}${server}${COLOR_RESET}: Server running despite ORANGE (runtime-disabled) state"
                echo -e "  ${COLOR_GREY}Bug: #13311 - disabledMcpServers not enforced at session start${COLOR_RESET}"
                echo -e "  ${COLOR_CYAN}Fix:${COLOR_RESET} Run '${COLOR_WHITE}mcp --strict-disable${COLOR_RESET}' before launching Claude"
                echo -e "       OR toggle to ${COLOR_RED}RED${COLOR_RESET} to fully disable"
                echo ""
            elif [[ "$issue_type" == "config_on_runtime_off" ]]; then
                echo -e "${COLOR_YELLOW}[MEDIUM]${COLOR_RESET} ${COLOR_WHITE}${server}${COLOR_RESET}: Server not running despite being enabled"
                echo -e "  ${COLOR_GREY}Possible causes: Server failed to start, connection error, or missing dependencies${COLOR_RESET}"
                echo -e "  ${COLOR_CYAN}Fix:${COLOR_RESET} Check server logs with '${COLOR_WHITE}claude mcp get ${server}${COLOR_RESET}'"
                echo -e "       OR restart Claude session to retry connection"
                echo ""
            fi
        done

        echo -e "${COLOR_WHITE}══════════════════════════════════════════════════════════════${COLOR_RESET}"
        echo -e "${COLOR_CYAN}RECOMMENDED ACTION${COLOR_RESET}"
        echo -e "${COLOR_WHITE}══════════════════════════════════════════════════════════════${COLOR_RESET}"
        echo ""
        echo -e "  ${COLOR_WHITE}Run:${COLOR_RESET} ./mcp --strict-disable && claude"
        echo ""
        echo -e "  ${COLOR_GREY}This converts ORANGE servers to RED before launching,${COLOR_RESET}"
        echo -e "  ${COLOR_GREY}ensuring disabled servers stay disabled.${COLOR_RESET}"
        echo ""
    else
        echo -e "${COLOR_GREEN}${MARK_SUCCESS} All servers in sync${COLOR_RESET}"
        echo ""
    fi

    return 0
}

# ============================================================================
# CONTEXT-REPORT COMMAND IMPLEMENTATION
# ============================================================================

# Show context token usage per server
run_context_report() {
    # Need to discover and load servers first
    discover_settings_file
    load_servers

    echo ""
    echo -e "${COLOR_WHITE}╔════════════════════════════════════════════════════════════╗${COLOR_RESET}"
    echo -e "${COLOR_WHITE}║${COLOR_RESET}              ${COLOR_CYAN}MCP Server Context Usage Report${COLOR_RESET}              ${COLOR_WHITE}║${COLOR_RESET}"
    echo -e "${COLOR_WHITE}╚════════════════════════════════════════════════════════════╝${COLOR_RESET}"
    echo ""

    # Check if Claude is available for tool count
    local claude_bin
    claude_bin=$(command -v claude 2>/dev/null)
    local can_get_tools=false
    [[ -n "$claude_bin" ]] && can_get_tools=true

    local enabled_total=0
    local enabled_tokens=0
    local disabled_total=0
    local disabled_tokens=0
    local orange_total=0
    local orange_tokens=0

    echo -e "${COLOR_GREEN}ENABLED SERVERS:${COLOR_RESET}"
    printf "  %-30s %-12s %s\n" "Server" "Tools" "Est. Tokens"
    printf "  %-30s %-12s %s\n" "──────────────────────────────" "────────────" "───────────"

    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^# ]] && continue

        local state=$(echo "$line" | cut -d: -f1)
        local server=$(echo "$line" | cut -d: -f2)
        local runtime=$(echo "$line" | cut -d: -f7)

        # Try to get tool count
        local tools="?"
        local tokens="?"
        if [[ "$can_get_tools" == true ]]; then
            local server_info
            server_info=$("$claude_bin" mcp get "$server" 2>/dev/null)
            if [[ -n "$server_info" ]]; then
                tools=$(echo "$server_info" | jq '.tools | length' 2>/dev/null || echo "?")
                if [[ "$tools" != "?" ]]; then
                    tokens=$((tools * 50))  # ~50 tokens per tool definition
                fi
            fi
        fi

        if [[ "$state" == "on" && "$runtime" != "stopped" ]]; then
            printf "  %-30s %-12s ~%s\n" "$server" "$tools tools" "${tokens} tokens"
            [[ "$tools" != "?" ]] && enabled_total=$((enabled_total + tools))
            [[ "$tokens" != "?" ]] && enabled_tokens=$((enabled_tokens + tokens))
        fi
    done < "$STATE_FILE"

    echo -e "  ──────────────────────────────────────────────────────────"
    echo -e "  ${COLOR_WHITE}Total enabled:${COLOR_RESET} $enabled_total tools (~$enabled_tokens tokens)"
    echo ""

    # Check for disabled servers (wasted context due to bug #11370)
    local has_disabled=false
    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^# ]] && continue
        local state=$(echo "$line" | cut -d: -f1)
        local runtime=$(echo "$line" | cut -d: -f7)
        if [[ "$state" == "off" ]] || [[ "$runtime" == "stopped" ]]; then
            has_disabled=true
            break
        fi
    done < "$STATE_FILE"

    if [[ "$has_disabled" == true ]]; then
        echo -e "${COLOR_YELLOW}DISABLED BUT LOADING (Bug #11370):${COLOR_RESET}"
        printf "  %-30s %-12s %s\n" "Server" "Tools" "Wasted Tokens"
        printf "  %-30s %-12s %s\n" "──────────────────────────────" "────────────" "─────────────"

        while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^# ]] && continue

            local state=$(echo "$line" | cut -d: -f1)
            local server=$(echo "$line" | cut -d: -f2)
            local runtime=$(echo "$line" | cut -d: -f7)

            local tools="?"
            local tokens="?"
            if [[ "$can_get_tools" == true ]]; then
                local server_info
                server_info=$("$claude_bin" mcp get "$server" 2>/dev/null)
                if [[ -n "$server_info" ]]; then
                    tools=$(echo "$server_info" | jq '.tools | length' 2>/dev/null || echo "?")
                    if [[ "$tools" != "?" ]]; then
                        tokens=$((tools * 50))
                    fi
                fi
            fi

            if [[ "$state" == "off" ]]; then
                printf "  %-30s %-12s ${COLOR_RED}~%s${COLOR_RESET}\n" "$server (RED)" "$tools tools" "${tokens} wasted"
                [[ "$tools" != "?" ]] && disabled_total=$((disabled_total + tools))
                [[ "$tokens" != "?" ]] && disabled_tokens=$((disabled_tokens + tokens))
            elif [[ "$runtime" == "stopped" ]]; then
                printf "  %-30s %-12s ${COLOR_YELLOW}~%s${COLOR_RESET}\n" "$server (ORANGE)" "$tools tools" "${tokens} wasted"
                [[ "$tools" != "?" ]] && orange_total=$((orange_total + tools))
                [[ "$tokens" != "?" ]] && orange_tokens=$((orange_tokens + tokens))
            fi
        done < "$STATE_FILE"

        local total_wasted=$((disabled_tokens + orange_tokens))
        echo -e "  ──────────────────────────────────────────────────────────"
        echo -e "  ${COLOR_RED}Total wasted:${COLOR_RESET} $((disabled_total + orange_total)) tools (~$total_wasted tokens)"
        echo ""
        echo -e "${COLOR_YELLOW}${MARK_WARNING} Bug #11370: Disabled servers still consume context tokens${COLOR_RESET}"
        echo -e "   Each disabled server wastes ~400-650 tokens of your context window."
        echo ""
        echo -e "${COLOR_CYAN}Recommendations:${COLOR_RESET}"
        echo -e "   • Use ${COLOR_WHITE}mcp --strict-disable${COLOR_RESET} to fully remove disabled servers"
        echo -e "   • Or remove servers you don't need: ${COLOR_WHITE}claude mcp remove <name>${COLOR_RESET}"
        echo ""
    fi

    # Summary
    echo -e "${COLOR_WHITE}SUMMARY:${COLOR_RESET}"
    echo -e "   Active context usage: ~$enabled_tokens tokens"
    if [[ $((disabled_tokens + orange_tokens)) -gt 0 ]]; then
        echo -e "   Wasted context (bugs): ~$((disabled_tokens + orange_tokens)) tokens"
        echo -e "   Potential savings:     ~$((disabled_tokens + orange_tokens)) tokens"
    fi
    echo ""
}

# ============================================================================
# ENABLE/DISABLE SERVER COMMANDS
# ============================================================================

# Enable servers via CLI
# Uses CMD_SERVERS array and CMD_ALL flag set by parse_args
run_enable_servers() {
    # Warn if running inside Claude session
    warn_if_in_session || true

    # Need to discover and load servers first
    discover_settings_file
    load_servers

    # Validate at least one server specified or --all
    if [[ ${#CMD_SERVERS[@]} -eq 0 && "$CMD_ALL" != "true" ]]; then
        msg_error "No servers specified. Use 'mcp enable SERVER' or 'mcp enable --all'"
        return 1
    fi

    local enabled_count=0
    local failed=()
    local servers_to_enable=()

    if [[ "$CMD_ALL" == "true" ]]; then
        # Collect all disabled servers
        while IFS=: read -r state server scope file source_type flags runtime; do
            [[ -z "$server" ]] && continue
            [[ -z "$flags" ]] && flags=""

            # Skip enterprise and blocked servers
            if [[ "$flags" == *"e"* ]] || [[ "$flags" == *"b"* ]] || [[ "$flags" == *"r"* ]]; then
                continue
            fi

            if [[ "$state" == "off" ]] || [[ "$runtime" == "stopped" ]]; then
                servers_to_enable+=("$server")
            fi
        done < "$STATE_FILE"
    else
        servers_to_enable=("${CMD_SERVERS[@]}")
    fi

    for server in "${servers_to_enable[@]}"; do
        # Check if server exists in state file
        if ! grep -q "^[^:]*:${server}:" "$STATE_FILE"; then
            failed+=("$server (not found)")
            continue
        fi

        # Get server info
        local line
        line=$(grep "^[^:]*:${server}:" "$STATE_FILE" | tail -1)
        local flags
        flags=$(echo "$line" | cut -d: -f6)
        [[ -z "$flags" ]] && flags=""

        # Check if server can be enabled
        if [[ "$flags" == *"e"* ]]; then
            failed+=("$server (enterprise-managed)")
            continue
        fi
        if [[ "$flags" == *"b"* ]]; then
            failed+=("$server (blocked by policy)")
            continue
        fi
        if [[ "$flags" == *"r"* ]]; then
            failed+=("$server (not in allowlist)")
            continue
        fi

        # Update state file: change off to on, and clear runtime=stopped
        # Format: state:server:scope:file:source_type:flags:runtime
        sed -i "s/^off:${server}:/on:${server}:/" "$STATE_FILE"
        # Also clear runtime=stopped (change to running)
        sed -i "s/^\([^:]*:${server}:[^:]*:[^:]*:[^:]*:[^:]*:\)stopped$/\1running/" "$STATE_FILE"
        ((enabled_count++)) || true
    done

    # Save changes (disable errexit temporarily as save_state_to_settings
    # may have internal commands that return non-zero)
    set +e
    save_state_to_settings
    local save_result=$?
    set -e

    if [[ $save_result -ne 0 ]]; then
        msg_error "Failed to save configuration changes"
        return 1
    fi

    # Output result
    if [[ "$AUDIT_JSON" == "true" ]]; then
        local failed_json="[]"
        if [[ ${#failed[@]} -gt 0 ]]; then
            failed_json=$(printf '%s\n' "${failed[@]}" | jq -R . | jq -s .)
        fi
        jq -n \
            --argjson count "$enabled_count" \
            --argjson failed "$failed_json" \
            '{enabled: $count, failed: $failed}'
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            if [[ $enabled_count -gt 0 ]]; then
                msg_success "Enabled $enabled_count server(s)"
            else
                msg_info "No servers were enabled"
            fi
        fi
        if [[ ${#failed[@]} -gt 0 ]]; then
            for f in "${failed[@]}"; do
                msg_warning "Failed: $f"
            done
        fi
    fi

    return 0
}

# Disable servers via CLI
# Uses CMD_SERVERS array and CMD_ALL flag set by parse_args
run_disable_servers() {
    # Warn if running inside Claude session
    warn_if_in_session || true

    # Need to discover and load servers first
    discover_settings_file
    load_servers

    # Validate at least one server specified or --all
    if [[ ${#CMD_SERVERS[@]} -eq 0 && "$CMD_ALL" != "true" ]]; then
        msg_error "No servers specified. Use 'mcp disable SERVER' or 'mcp disable --all'"
        return 1
    fi

    local disabled_count=0
    local failed=()
    local servers_to_disable=()

    if [[ "$CMD_ALL" == "true" ]]; then
        # Collect all enabled servers
        while IFS=: read -r state server scope file source_type flags runtime; do
            [[ -z "$server" ]] && continue
            [[ -z "$flags" ]] && flags=""

            # Skip enterprise servers (cannot modify)
            if [[ "$flags" == *"e"* ]]; then
                continue
            fi

            if [[ "$state" == "on" ]] && [[ "$runtime" != "stopped" ]]; then
                servers_to_disable+=("$server")
            fi
        done < "$STATE_FILE"
    else
        servers_to_disable=("${CMD_SERVERS[@]}")
    fi

    for server in "${servers_to_disable[@]}"; do
        # Check if server exists in state file
        if ! grep -q "^[^:]*:${server}:" "$STATE_FILE"; then
            failed+=("$server (not found)")
            continue
        fi

        # Get server info
        local line
        line=$(grep "^[^:]*:${server}:" "$STATE_FILE" | tail -1)
        local flags
        flags=$(echo "$line" | cut -d: -f6)
        [[ -z "$flags" ]] && flags=""

        # Check if server can be disabled
        if [[ "$flags" == *"e"* ]]; then
            failed+=("$server (enterprise-managed)")
            continue
        fi

        # Update state file: change on to off
        # Format: state:server:scope:file:source_type:flags:runtime
        sed -i "s/^on:${server}:/off:${server}:/" "$STATE_FILE"
        ((disabled_count++)) || true
    done

    # Save changes (disable errexit temporarily as save_state_to_settings
    # may have internal commands that return non-zero)
    set +e
    save_state_to_settings
    local save_result=$?
    set -e

    if [[ $save_result -ne 0 ]]; then
        msg_error "Failed to save configuration changes"
        return 1
    fi

    # Output result
    if [[ "$AUDIT_JSON" == "true" ]]; then
        local failed_json="[]"
        if [[ ${#failed[@]} -gt 0 ]]; then
            failed_json=$(printf '%s\n' "${failed[@]}" | jq -R . | jq -s .)
        fi
        jq -n \
            --argjson count "$disabled_count" \
            --argjson failed "$failed_json" \
            '{disabled: $count, failed: $failed}'
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            if [[ $disabled_count -gt 0 ]]; then
                msg_success "Disabled $disabled_count server(s)"
            else
                msg_info "No servers were disabled"
            fi
        fi
        if [[ ${#failed[@]} -gt 0 ]]; then
            for f in "${failed[@]}"; do
                msg_warning "Failed: $f"
            done
        fi
    fi

    return 0
}

# ============================================================================
# STRICT-DISABLE IMPLEMENTATION
# ============================================================================

# Convert all ORANGE servers to RED (strict disable)
apply_strict_disable() {
    # Warn if running inside Claude session
    warn_if_in_session || true

    local cwd
    cwd=$(pwd)
    local changed=false

    if [[ ! -f "$HOME/.claude.json" ]]; then
        return 0
    fi

    # Get list of runtime-disabled servers
    local disabled_list
    disabled_list=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers // [] | .[]' "$HOME/.claude.json" 2>/dev/null || true)

    [[ -z "$disabled_list" ]] && return 0

    msg_info "Applying strict-disable: Converting ORANGE servers to RED..."

    # For each runtime-disabled server, add to disabledMcpjsonServers
    local settings_file="./.claude/settings.local.json"
    mkdir -p "./.claude"

    if [[ ! -f "$settings_file" ]]; then
        echo '{}' > "$settings_file"
    fi

    while IFS= read -r server; do
        [[ -z "$server" ]] && continue

        # Add to disabledMcpjsonServers
        local temp_file
        temp_file=$(mktemp)
        jq --arg server "$server" '
            .disabledMcpjsonServers = ((.disabledMcpjsonServers // []) + [$server] | unique)
        ' "$settings_file" > "$temp_file"
        mv "$temp_file" "$settings_file"

        msg_info "  Disabled: $server"
        changed=true
    done <<< "$disabled_list"

    # Clear the runtime override list
    if [[ "$changed" == "true" ]]; then
        local temp_file
        temp_file=$(mktemp)
        jq --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers = []' "$HOME/.claude.json" > "$temp_file"
        mv "$temp_file" "$HOME/.claude.json"

        msg_success "ORANGE servers converted to RED (permanent disable)"
    fi
}

# ============================================================================
# BOX DRAWING UTILITIES
# ============================================================================

# Strip ANSI escape codes from text for accurate length calculation
# Args: $1 - text with ANSI codes
# Returns: text without ANSI codes
strip_ansi() {
    local text="$1"
    # Comprehensive ANSI stripping: matches ESC [ ... [any letter]
    # This covers SGR (colors), cursor movement, erasing, etc.
    echo "$text" | sed -E 's/\x1b\[[0-9;]*[a-zA-Z]//g'
}

# Calculate visual width of text (excludes ANSI codes)
# Args: $1 - text (may contain ANSI codes)
# Returns: numeric width
visual_width() {
    local text="$1"
    local stripped
    stripped=$(strip_ansi "$text")
    echo "${#stripped}"
}

# Truncate text to fit within width with ellipsis
# Args: $1 - text, $2 - max width
# Returns: truncated text with ... if needed
truncate_text() {
    local text="$1"
    local max_width="$2"
    local vwidth
    vwidth=$(visual_width "$text")

    if [[ $vwidth -le $max_width ]]; then
        echo "$text"
    else
        # Strip ANSI, truncate, add ellipsis
        local stripped
        stripped=$(strip_ansi "$text")
        echo "${stripped:0:$((max_width - 3))}..."
    fi
}

# Extract clean server name from fzf selection
# Args: $1 - raw input from fzf (with ANSI codes, prefixes, badges, scope)
# Returns: clean server name
extract_server_name() {
    local raw_input="$1"
    echo "$raw_input" | \
        sed 's/\x1b\[[0-9;]*m//g' | \
        sed 's/^● *//' | \
        sed 's/^○ *//' | \
        sed 's/^⚠ *//' | \
        sed 's/^\[ON \] *//' | \
        sed 's/^\[OFF\] *//' | \
        sed 's/^\[⚠ \] *//' | \
        sed 's/^     *//' | \
        sed 's/ *\[plugin\] *//' | \
        sed 's/ *\[direct\] *//' | \
        sed 's/ *│.*//' | \
        awk '{print $1}'
}

# ============================================================================
# DEPENDENCY CHECKING
# ============================================================================

# Check for required dependencies (fzf, jq)
# Exits with error if missing, provides OS-specific installation instructions
check_dependencies() {
    local missing_deps=()

    for cmd in fzf jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        return 0
    fi

    msg_error "Missing required dependencies: ${missing_deps[*]}"
    echo ""

    local os
    os=$(detect_os)

    case "$os" in
        Linux)
            # Detect Linux package manager
            if command -v apt &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo apt update && sudo apt install ${missing_deps[*]}"
            elif command -v dnf &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo dnf install ${missing_deps[*]}"
            elif command -v yum &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo yum install ${missing_deps[*]}"
            elif command -v pacman &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo pacman -S ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install using your system's package manager${COLOR_RESET}"
            fi
            ;;
        Darwin)
            if command -v brew &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install Homebrew first:${COLOR_RESET}"
                echo "  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo ""
                echo -e "${COLOR_CYAN}Then install dependencies:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            fi
            ;;
        *)
            echo -e "${COLOR_CYAN}Please install: ${missing_deps[*]}${COLOR_RESET}"
            ;;
    esac

    exit 1
}

# ============================================================================
# FORMAT DETECTION & PARSING
# ============================================================================

# Detect configuration file format
# Args: $1 - file path
# Returns: "mcp" or "settings" or "unknown"
detect_file_format() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        echo "unknown"
        return 1
    fi

    if ! jq empty "$file" 2>/dev/null; then
        echo "unknown"
        return 1
    fi

    # Check for mcpServers object
    if jq -e '.mcpServers' "$file" >/dev/null 2>&1; then
        echo "mcp"
        return 0
    fi

    # Check for enabledMcpjsonServers or disabledMcpjsonServers arrays
    if jq -e '.enabledMcpjsonServers' "$file" >/dev/null 2>&1 || \
       jq -e '.disabledMcpjsonServers' "$file" >/dev/null 2>&1; then
        echo "settings"
        return 0
    fi

    echo "unknown"
    return 1
}

# Get numeric priority for scope (for precedence resolution)
# Args: $1 - scope label (enterprise/local/project/user)
# Returns: numeric priority (4=highest, 1=lowest)
get_scope_priority() {
    case "$1" in
        enterprise) echo 4 ;;  # NEW: Highest priority (immutable)
        local) echo 3 ;;
        project) echo 2 ;;
        user) echo 1 ;;
        *) echo 0 ;;
    esac
}

# Parse settings file (extracts enable/disable arrays ONLY, not mcpServers definitions)
# Args: $1 - file path, $2 - scope label (local/project/user)
# Output: Lines in format "type:server:scope:file"
# Types: enable (server enabled), disable (server disabled)
# Example: enable:fetch:user:~/.claude/settings.json
parse_settings_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # OPTIMIZATION: Extract both enabled and disabled in single jq call
    local json_output
    json_output=$(jq -r '(.enabledMcpjsonServers[]? // empty | "enable:" + .), (.disabledMcpjsonServers[]? // empty | "disable:" + .)' "$file" 2>/dev/null | sort -u)

    # Output servers with type prefix already attached
    if [[ -n "$json_output" ]]; then
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                # line format: "enable:server" or "disable:server"
                echo "$line:$scope:$file"
            fi
        done <<< "$json_output"
    fi
}

# Parse .mcp.json file (mcpServers object format only, no enable/disable arrays)
# Args: $1 - file path, $2 - scope label (project only, not used for ~/.claude.json)
# Output: Lines in format "def:server:scope:file:source_type"
# Example: def:coingecko:project:./.mcp.json:mcpjson
parse_mcp_json_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract server names from mcpServers object keys
    local servers
    servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:$scope:$file:mcpjson"
        done <<< "$servers"
    fi
}

# Parse ~/.claude.json file (handles BOTH user and project-specific scopes)
# Args: $1 - file path (~/.claude.json)
# Output: Lines in format "type:server:scope:file:source_type"
# Types: def (server defined), enable (server enabled), disable (server disabled)
# Scopes: user (root .mcpServers), local (under .projects[cwd])
# Source types: direct-global (root), direct-local (projects)
# Example: def:fetch:user:~/.claude.json:direct-global
#          def:stripe:local:~/.claude.json:direct-local
#          enable:time:local:~/.claude.json
parse_claude_json_file() {
    local file="$1"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Get current working directory for project matching
    local cwd
    cwd=$(pwd)

    # Parse user-scope servers (root level .mcpServers) - DIRECT-GLOBAL (always enabled)
    local user_servers
    user_servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$user_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:user:$file:direct-global"
        done <<< "$user_servers"
    fi

    # Parse local-scope servers (project-specific .projects[cwd].mcpServers) - DIRECT-LOCAL (always enabled)
    local local_servers
    local_servers=$(jq -r --arg cwd "$cwd" '.projects[$cwd].mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$local_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:local:$file:direct-local"
        done <<< "$local_servers"
    fi

    # Parse local-scope enabled servers (.projects[cwd].enabledMcpjsonServers)
    # NOTE: These are removed by Claude Code on launch, but we parse them for completeness
    local enabled
    enabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].enabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$enabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "enable:$server:local:$file"
        done <<< "$enabled"
    fi

    # Parse local-scope disabled servers (.projects[cwd].disabledMcpjsonServers)
    # NOTE: These are removed by Claude Code on launch, but we parse them for completeness
    local disabled
    disabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$disabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:local:$file"
        done <<< "$disabled"
    fi

    # Parse local-scope disabled DIRECT servers (.projects[cwd].disabledMcpServers)
    # This controls Direct-Global and Direct-Local servers (from .mcpServers sections)
    # ALSO handles plugin servers in Claude Code's format: "plugin:NAME:KEY"
    local disabled_direct
    disabled_direct=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$disabled_direct" ]]; then
        while IFS= read -r server; do
            [[ -z "$server" ]] && continue

            # Transform Claude Code's plugin format to our internal format
            # Claude Code format: "plugin:mcp-fetch:fetch"
            # Our format: "mcp-fetch@marketplace-name"
            if [[ "$server" =~ ^plugin:([^:]+): ]]; then
                local plugin_name="${BASH_REMATCH[1]}"
                # Output disable directive using just the plugin name prefix
                # This will match against "plugin_name@*" during state resolution
                echo "disable-plugin:$plugin_name:local:$file"
            else
                echo "disable:$server:local:$file"
            fi
        done <<< "$disabled_direct"
    fi
}

# Parse enabledPlugins from settings files
# Args: $1 - file path, $2 - scope label (local/project/user)
# Output: Lines in format "type:plugin_server:scope:file"
# Types: enable (plugin enabled), disable (plugin disabled)
# Example: enable:mcp-fetch@claudecode-marketplace:user:~/.claude/settings.json
parse_enabled_plugins() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract enabledPlugins object
    local plugins_json
    plugins_json=$(jq -r '.enabledPlugins // {}' "$file" 2>/dev/null)

    if [[ "$plugins_json" == "{}" ]]; then
        return 0
    fi

    # Parse each plugin: server -> enabled state
    echo "$plugins_json" | jq -r 'to_entries[] | "\(.key):\(.value)"' | while IFS=: read -r plugin_name enabled_state; do
        [[ -z "$plugin_name" ]] && continue

        if [[ "$enabled_state" == "true" ]]; then
            echo "enable:$plugin_name:$scope:$file"
        else
            echo "disable:$plugin_name:$scope:$file"
        fi
    done
}

# Discover plugin servers from marketplace installations
# Output: Lines in format "def:server:scope:file:plugin"
# Example: def:developer-toolkit@wookstar:user:~/.claude/plugins/marketplaces/wookstar/.../developer-toolkit/.mcp.json:plugin
#
# ENHANCEMENT v1.5.0: Now discovers ALL plugins with .mcp.json files, not just those
# with category=="mcpServers". Uses the plugin's .source field to directly locate
# .mcp.json files, ensuring complete coverage while maintaining naming compatibility
# with enabledPlugins control mechanism.
parse_plugin_marketplace_files() {
    local marketplace_dir="$HOME/.claude/plugins/marketplaces"

    if [[ ! -d "$marketplace_dir" ]]; then
        return 0
    fi

    # Find all marketplace.json files
    while IFS= read -r marketplace_file; do
        [[ ! -f "$marketplace_file" ]] && continue
        [[ ! -s "$marketplace_file" ]] && continue

        # Validate JSON
        if ! jq empty "$marketplace_file" 2>/dev/null; then
            msg_warning "Skipping invalid marketplace JSON: $marketplace_file"
            continue
        fi

        # Extract marketplace name from path using safe parameter expansion
        local rel_path="${marketplace_file#$marketplace_dir/}"
        local marketplace_name="${rel_path%%/*}"

        # Get marketplace base directory (parent of .claude-plugin)
        local marketplace_base
        marketplace_base=$(dirname "$marketplace_file")
        marketplace_base=$(dirname "$marketplace_base")

        # FIRST: Check for root-level mcpServers in marketplace.json itself
        local has_root_servers
        has_root_servers=$(jq -r 'has("mcpServers")' "$marketplace_file" 2>/dev/null)
        if [[ "$has_root_servers" == "true" ]]; then
            # Parse servers from root-level mcpServers object
            local root_servers
            root_servers=$(jq -r '.mcpServers | keys[]? // empty' "$marketplace_file" 2>/dev/null)
            if [[ -n "$root_servers" ]]; then
                while IFS= read -r server; do
                    [[ -z "$server" ]] && continue
                    # Format: server@marketplace (root-level servers use server name directly)
                    local full_name="${server}@${marketplace_name}"
                    echo "def:${full_name}:user:${marketplace_file}:plugin"
                done <<< "$root_servers"
            fi
        fi

        # SECOND: For EACH plugin (regardless of category), check if .source/.mcp.json exists
        jq -r '.plugins[]? | "\(.name):\(.source)"' "$marketplace_file" 2>/dev/null | \
        while IFS=: read -r plugin_name plugin_source; do
            [[ -z "$plugin_name" ]] || [[ -z "$plugin_source" ]] && continue

            # Security: Validate source path (prevent path traversal)
            if [[ "$plugin_source" =~ \.\. ]] || [[ "$plugin_source" =~ ^/ ]]; then
                msg_warning "Skipping plugin with unsafe path: $plugin_name ($plugin_source)"
                continue
            fi

            # Construct path to .mcp.json using .source field
            local mcp_file="${marketplace_base}/${plugin_source}/.mcp.json"

            # Check if .mcp.json exists for this plugin
            [[ ! -f "$mcp_file" ]] && continue

            # Validate .mcp.json structure
            if ! jq empty "$mcp_file" 2>/dev/null; then
                msg_warning "Skipping plugin with invalid .mcp.json: $plugin_name ($mcp_file)"
                continue
            fi

            # Check if .mcp.json has mcpServers object
            local has_servers
            has_servers=$(jq -r 'has("mcpServers")' "$mcp_file" 2>/dev/null)
            [[ "$has_servers" != "true" ]] && continue

            # Output using PLUGIN NAME (not server names from .mcp.json)
            # Format: plugin-name@marketplace
            # This ensures compatibility with enabledPlugins control mechanism
            local full_name="${plugin_name}@${marketplace_name}"
            echo "def:${full_name}:user:${mcp_file}:plugin"
        done
    done < <(find "$marketplace_dir" -path "*/.claude-plugin/marketplace.json" -type f 2>/dev/null)
}

# ============================================================================
# ENTERPRISE CONFIGURATION PARSING
# ============================================================================

# Parse enterprise MCP servers from managed-mcp.json
# Output: Lines in format "def:server:enterprise:file:mcpjson:e"
# Flag 'e' = enterprise-managed (immutable)
parse_enterprise_mcp_json() {
    local file
    file=$(get_enterprise_mcp_path)

    # No file = no enterprise servers
    [[ -z "$file" ]] || [[ ! -f "$file" ]] && return 0

    # Validate JSON
    if ! jq empty "$file" 2>/dev/null; then
        msg_warning "Enterprise MCP file has invalid JSON: $file"
        return 1
    fi

    # Parse mcpServers object keys
    local servers
    servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null)

    [[ -z "$servers" ]] && return 0

    # Output with enterprise scope and flag
    while IFS= read -r server; do
        [[ -n "$server" ]] && echo "def:${server}:enterprise:${file}:mcpjson:e"
        ((ENTERPRISE_SERVER_COUNT++))
    done <<< "$servers"
}

# Parse enterprise restrictions from managed-settings.json
# Sets global variables: ALLOWED_SERVERS, DENIED_SERVERS, ENTERPRISE_MODE, RESTRICTION_TYPE
# Returns: 0 on success, 1 on error (triggers lockdown mode)
parse_enterprise_restrictions() {
    local file
    file=$(get_enterprise_settings_path)

    # No file = no restrictions
    if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
        ENTERPRISE_MODE="none"
        return 0
    fi

    # Validate JSON - CRITICAL for security
    if ! jq empty "$file" 2>/dev/null; then
        # FAIL-SAFE: Invalid JSON = lockdown mode
        msg_error "Enterprise settings file has invalid JSON: $file"
        msg_error "Enforcing lockdown mode for security"
        ENTERPRISE_MODE="lockdown"
        return 1
    fi

    # Parse allowedMcpServers
    local allowed_raw
    allowed_raw=$(jq -r '.allowedMcpServers[]?.serverName // empty' "$file" 2>/dev/null)
    if [[ -n "$allowed_raw" ]]; then
        mapfile -t ALLOWED_SERVERS <<< "$allowed_raw"
    fi

    # Parse deniedMcpServers
    local denied_raw
    denied_raw=$(jq -r '.deniedMcpServers[]?.serverName // empty' "$file" 2>/dev/null)
    if [[ -n "$denied_raw" ]]; then
        mapfile -t DENIED_SERVERS <<< "$denied_raw"
    fi

    # Determine restriction type
    if [[ ${#ALLOWED_SERVERS[@]} -gt 0 ]] && [[ ${#DENIED_SERVERS[@]} -gt 0 ]]; then
        RESTRICTION_TYPE="both"
    elif [[ ${#ALLOWED_SERVERS[@]} -gt 0 ]]; then
        RESTRICTION_TYPE="allowlist"
    elif [[ ${#DENIED_SERVERS[@]} -gt 0 ]]; then
        RESTRICTION_TYPE="denylist"
    else
        RESTRICTION_TYPE="none"
    fi

    ENTERPRISE_MODE="active"
    return 0
}

# Check if server is in allowlist
# Args: $1 - server name
# Returns: 0 if in allowlist (or no allowlist), 1 if not
server_in_allowlist() {
    local server="$1"

    # No allowlist = all allowed
    [[ ${#ALLOWED_SERVERS[@]} -eq 0 ]] && return 0

    # Check membership
    for allowed in "${ALLOWED_SERVERS[@]}"; do
        [[ "$allowed" == "$server" ]] && return 0
    done

    return 1
}

# Check if server is in denylist
# Args: $1 - server name
# Returns: 0 if in denylist, 1 if not
server_in_denylist() {
    local server="$1"

    # No denylist = none denied
    [[ ${#DENIED_SERVERS[@]} -eq 0 ]] && return 1

    # Check membership
    for denied in "${DENIED_SERVERS[@]}"; do
        [[ "$denied" == "$server" ]] && return 0
    done

    return 1
}

# Main validation function - implements truth table from ENTERPRISE_FEATURE_PLAN.md
# Args: $1 - server name, $2 - scope (enterprise/local/project/user)
# Returns: 0 if allowed, 1 if blocked
is_server_allowed() {
    local server="$1"
    local scope="${2:-user}"

    # Lockdown mode - only allow enterprise servers
    if [[ "$ENTERPRISE_MODE" == "lockdown" ]]; then
        [[ "$scope" == "enterprise" ]] && return 0 || return 1
    fi

    # Rule 1: Denylist is absolute (blocks ALL scopes including enterprise)
    server_in_denylist "$server" && return 1

    # Rule 2: Enterprise servers bypass allowlist
    [[ "$scope" == "enterprise" ]] && return 0

    # Rule 3: Check allowlist (only for non-enterprise)
    # If allowlist exists (even if empty), it acts as whitelist
    if [[ ${#ALLOWED_SERVERS[@]} -gt 0 ]] || \
       jq -e '.allowedMcpServers' "$(get_enterprise_settings_path)" &>/dev/null; then
        server_in_allowlist "$server" && return 0 || return 1
    fi

    # Rule 4: No restrictions
    return 0
}

# ============================================================================
# CONFIGURATION DISCOVERY & NEW PROJECT FLOW
# ============================================================================

# Check for configuration and handle new project flow if needed
# No longer sets SETTINGS_FILE_PATH or SETTINGS_SCOPE (multi-source approach)
discover_settings_file() {
    local current_dir
    current_dir=$(pwd)

    # Check if any local config exists
    if [[ -f "$current_dir/.claude/settings.local.json" ]] || \
       [[ -f "$current_dir/.claude/settings.json" ]] || \
       [[ -f "$current_dir/.mcp.json" ]]; then
        # Local config exists, proceed normally
        return 0
    fi

    # No local config, check if global exists
    if [[ -f "$HOME/.claude/settings.json" ]] || \
       [[ -f "$HOME/.claude/settings.local.json" ]] || \
       [[ -f "$HOME/.claude.json" ]]; then
        # Global config exists, trigger new project flow
        handle_new_project_prompt
        return $?
    fi

    # No configuration found anywhere
    msg_error "No Claude configuration found (local or global)"
    echo ""
    echo "Please configure Claude first by running 'claude' once."
    exit 1
}

# Handle new project initialization flow
# Prompts user to create local config or use global
handle_new_project_prompt() {
    clear
    msg_header "New Project Detected"
    echo ""
    echo "You are in a directory without a local Claude configuration."
    echo "Global configuration will be used as a template."
    echo ""
    echo "What would you like to do?"
    echo ""
    echo -e "  ${COLOR_GREEN}1)${COLOR_RESET} Create local configuration (.claude/settings.local.json) for this project ${COLOR_CYAN}(Recommended)${COLOR_RESET}"
    echo -e "  ${COLOR_YELLOW}2)${COLOR_RESET} Continue with global settings only (changes will still be saved to local)"
    echo -e "  ${COLOR_RED}3)${COLOR_RESET} Abort"
    echo ""

    local choice
    read -rp "Enter your choice [1-3]: " choice

    case "$choice" in
        1)
            # Create local config from global template
            msg_info "Creating local configuration..."
            mkdir -p ./.claude

            # Find global settings file to use as template
            local template=""
            if [[ -f "$HOME/.claude/settings.json" ]]; then
                template="$HOME/.claude/settings.json"
            elif [[ -f "$HOME/.claude/settings.local.json" ]]; then
                template="$HOME/.claude/settings.local.json"
            elif [[ -f "$HOME/.claude.json" ]]; then
                template="$HOME/.claude.json"
            else
                # Create empty settings
                echo '{}' > "./.claude/settings.local.json"
                msg_success "Created empty ./.claude/settings.local.json"
                echo ""
                return 0
            fi

            cp "$template" "./.claude/settings.local.json"
            msg_success "Created ./.claude/settings.local.json from $template"
            echo ""
            return 0
            ;;
        2)
            # Continue without creating local config
            # Changes will still be saved to .claude/settings.local.json when user confirms
            msg_info "Continuing with global settings..."
            echo ""
            return 0
            ;;
        3|*)
            # Abort
            msg_warning "Operation cancelled"
            exit 0
            ;;
    esac
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

# Get currently running MCP servers from Claude Code runtime
# Returns: List of server names (one per line)
# Example: mcp-fetch@wookstar, fetch, time
get_runtime_servers() {
    local runtime_output
    runtime_output=$(claude mcp list 2>/dev/null)

    # Parse the output to extract server names
    # Format examples:
    #   plugin:mcp-fetch:fetch: ... -> mcp-fetch@wookstar (we need to map back to config name)
    #   fetch: ... -> fetch
    # For plugins, we need to extract the plugin name from "plugin:NAME:..."
    echo "$runtime_output" | grep -v "Checking MCP" | while read -r line; do
        # Extract the first field before ":"
        local server_id
        server_id=$(echo "$line" | awk -F: '{print $1}')

        if [[ "$server_id" == "plugin" ]]; then
            # Plugin format: plugin:mcp-NAME:...
            # Extract the plugin name and check config for marketplace
            local plugin_name
            plugin_name=$(echo "$line" | awk -F: '{print $2}')

            # Try to find the matching plugin in our config
            # For now, we'll just output the plugin name and let the matching happen later
            echo "plugin:$plugin_name"
        else
            # Direct server
            echo "direct:$server_id"
        fi
    done
}

# Check if a server is currently running in Claude Code
# Args: $1 - server name (e.g., mcp-fetch@wookstar, fetch)
# Returns: 0 if running, 1 if not
is_server_running() {
    local server="$1"
    local runtime_servers
    runtime_servers=$(get_runtime_servers)

    # For plugin servers, extract the plugin name without marketplace
    if [[ "$server" =~ @ ]]; then
        local plugin_base
        plugin_base=$(echo "$server" | sed 's/@.*//')
        # Check if any runtime line matches this plugin
        echo "$runtime_servers" | grep -q "^plugin:$plugin_base$"
    else
        # For direct servers, match exactly
        echo "$runtime_servers" | grep -q "^direct:$server$"
    fi
}

# Discover and parse all configuration sources
# mcpServers definitions can exist in:
#   - managed-mcp.json (enterprise-scope) - ENTERPRISE (always enabled, immutable) [NEW]
#   - ~/.claude.json (user-scope root & project-scope .projects[cwd]) - DIRECT (always enabled)
#   - ~/.mcp.json (user-scope) - MCPJSON (controllable)
#   - ./.mcp.json (project-scope) - MCPJSON (controllable)
# Enable/disable arrays ONLY work for MCPJSON servers (from .mcp.json files)
# Output: Lines in format "type:server:scope:file:source_type"
discover_and_parse_all_sources() {
    local temp_raw
    temp_raw=$(mktemp)

    # Parse enterprise configurations FIRST (highest priority)
    parse_enterprise_restrictions  # Sets global flags for validation
    parse_enterprise_mcp_json >> "$temp_raw"

    # Parse ~/.claude.json (handles both user-scope root AND local-scope project entries)
    # Also extracts enable/disable arrays from .projects[cwd] (though Claude Code removes them)
    parse_claude_json_file "$HOME/.claude.json" >> "$temp_raw"

    # Parse ~/.mcp.json (user-scope mcpServers - MCPJSON type, controllable)
    parse_mcp_json_file "$HOME/.mcp.json" "user" >> "$temp_raw"

    # Parse ./.mcp.json (project-scope mcpServers - MCPJSON type, controllable)
    parse_mcp_json_file "./.mcp.json" "project" >> "$temp_raw"

    # Parse enable/disable arrays from all settings files (reverse precedence order)
    # User scope (lowest priority)
    parse_settings_file "$HOME/.claude/settings.json" "user" >> "$temp_raw"
    parse_settings_file "$HOME/.claude/settings.local.json" "user" >> "$temp_raw"

    # Project scope
    parse_settings_file "./.claude/settings.json" "project" >> "$temp_raw"

    # Local scope (highest priority)
    parse_settings_file "./.claude/settings.local.json" "local" >> "$temp_raw"

    # Parse plugin servers from marketplace installations
    parse_plugin_marketplace_files >> "$temp_raw"

    # Parse enabledPlugins from all settings files (reverse precedence order)
    # User scope (lowest priority)
    parse_enabled_plugins "$HOME/.claude/settings.json" "user" >> "$temp_raw"
    parse_enabled_plugins "$HOME/.claude/settings.local.json" "user" >> "$temp_raw"

    # Project scope
    parse_enabled_plugins "./.claude/settings.json" "project" >> "$temp_raw"

    # Local scope (highest priority)
    parse_enabled_plugins "./.claude/settings.local.json" "local" >> "$temp_raw"

    cat "$temp_raw"
    rm -f "$temp_raw"
}

# Load servers from all sources with DUAL precedence resolution
# Separates server definitions from enable/disable state
# State format: "state:server:def_scope:def_file:source_type" (one per line)
# Example: "on:fetch:project:./.mcp.json:mcpjson"
# Where state=on/off, def_scope/def_file=where server is DEFINED, source_type=mcpjson/direct-global/direct-local
load_servers() {
    local raw_data
    raw_data=$(discover_and_parse_all_sources)

    if [[ -z "$raw_data" ]]; then
        msg_warning "No MCP servers found in any configuration file"
        echo ""
        msg_info "You can add servers using Ctrl-A in the TUI"
        echo ""
        touch "$STATE_FILE"
        return 0
    fi

    # Build two separate maps for dual precedence resolution
    # Map 1: Server definitions (where server is configured)
    # Key: server_name, Value: priority:scope:file:source_type
    declare -A server_definitions

    # Map 2: Enable/disable state (whether server is active)
    # Key: server_name, Value: priority:state (on/off)
    declare -A server_states

    # Parse raw data and populate both maps
    while IFS=: read -r type server scope file source_type; do
        [[ -z "$server" ]] && continue

        local priority
        priority=$(get_scope_priority "$scope")

        if [[ "$type" == "def" ]]; then
            # This is a server definition
            local new_value="$priority:$scope:$file:$source_type"

            if [[ -n "${server_definitions[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_definitions[$server]}" | cut -d: -f1)

                # Higher or equal priority wins (later parsed files override)
                # Use >= to allow later entries with same priority to override
                if [[ $priority -ge $existing_priority ]]; then
                    server_definitions[$server]="$new_value"
                fi
            else
                server_definitions[$server]="$new_value"
            fi

        elif [[ "$type" == "enable" ]]; then
            # This is an enable directive
            local new_value="$priority:on"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                # Use >= to allow later entries with same priority to override
                # (e.g., settings.local.json overrides settings.json within same scope)
                if [[ $priority -ge $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi

        elif [[ "$type" == "disable" ]]; then
            # This is a disable directive
            local new_value="$priority:off"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                # Use >= to allow later entries with same priority to override
                # (e.g., settings.local.json overrides settings.json within same scope)
                if [[ $priority -ge $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi

        elif [[ "$type" == "disable-plugin" ]]; then
            # This is a plugin disable directive from Claude Code's format
            # Match all plugin servers that start with this plugin name
            # Example: "mcp-fetch" matches "mcp-fetch@wookstar", "mcp-fetch@claudecode-marketplace"
            local plugin_prefix="$server"
            local new_value="$priority:off"

            # Find and disable all matching plugin servers
            for plugin_server in "${!server_definitions[@]}"; do
                if [[ "$plugin_server" =~ ^${plugin_prefix}@ ]]; then
                    if [[ -n "${server_states[$plugin_server]:-}" ]]; then
                        local existing_priority
                        existing_priority=$(echo "${server_states[$plugin_server]}" | cut -d: -f1)

                        # Use >= to allow later entries with same priority to override
                        if [[ $priority -ge $existing_priority ]]; then
                            server_states[$plugin_server]="$new_value"
                        fi
                    else
                        server_states[$plugin_server]="$new_value"
                    fi
                fi
            done
        fi
    done <<< "$raw_data"

    # Write to state file with version header
    # Format v2.0: state:server:scope:file:source_type:flags:runtime
    echo "# schema_version:2.0" > "$STATE_FILE"

    # PERFORMANCE OPTIMIZATION: Skip runtime detection by default (saves 5-8 seconds)
    # Runtime detection requires calling 'claude mcp list' which is SLOW
    # Instead, we determine ORANGE state from disabledMcpServers only
    local runtime_servers_cache=""
    local runtime_query_success="false"

    # FAST_MODE can be disabled via env var for debugging: FAST_MODE=false ./mcp
    local FAST_MODE="${FAST_MODE:-true}"

    if [[ "$FAST_MODE" == "false" ]]; then
        # Slow path: Query actual runtime status (for debugging only)
        runtime_servers_cache=$(get_runtime_servers 2>/dev/null || true)
        runtime_query_success=$([[ -n "$runtime_servers_cache" ]] && echo "true" || echo "false")
    fi

    # Get runtime overrides from ~/.claude.json .projects[cwd].disabledMcpServers
    # These represent servers disabled in Claude Code UI (runtime-only, not config)
    # This is FAST (just jq query, no Claude CLI startup)
    local cwd=$(pwd)
    local runtime_overrides
    runtime_overrides=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers[]? // empty' "$HOME/.claude.json" 2>/dev/null || true)

    # Merge: For each defined server, attach its state and source type
    for server in "${!server_definitions[@]}"; do
        local def_value="${server_definitions[$server]}"
        # Extract scope:file:source_type from priority:scope:file:source_type
        local def_scope def_file source_type
        def_scope=$(echo "$def_value" | cut -d: -f2)
        def_file=$(echo "$def_value" | cut -d: -f3)
        source_type=$(echo "$def_value" | cut -d: -f4)

        # Get state (default to "on" if not mentioned in any enable/disable array)
        # MCPJSON servers are enabled by default unless explicitly disabled
        # DIRECT servers are ALWAYS enabled (but we track state for migration purposes)
        local state="on"
        if [[ -n "${server_states[$server]:-}" ]]; then
            local state_value="${server_states[$server]}"
            state=$(echo "$state_value" | cut -d: -f2)
        fi

        # Determine flags based on scope and validation (NEW: Phase 3)
        local flags=""

        # Enterprise servers get 'e' flag (immutable)
        if [[ "$def_scope" == "enterprise" ]]; then
            flags="e"
        fi

        # Check if server is blocked/restricted (for non-enterprise)
        if [[ "$def_scope" != "enterprise" ]]; then
            if server_in_denylist "$server"; then
                flags="${flags}b"
            elif ! is_server_allowed "$server" "$def_scope"; then
                flags="${flags}r"
            fi
        fi

        # Check runtime status (running/stopped/unknown) using cached result
        local runtime_status="unknown"

        # First check if server is in runtime override list (disabledMcpServers)
        # This takes precedence over actual runtime state
        local is_runtime_disabled="false"
        if [[ -n "$runtime_overrides" ]]; then
            if [[ "$server" =~ @ ]]; then
                # Plugin server - check for "plugin:mcp-NAME:..." format
                local plugin_base
                plugin_base=$(echo "$server" | sed 's/@.*//')
                if echo "$runtime_overrides" | grep -q "^plugin:$plugin_base:"; then
                    is_runtime_disabled="true"
                fi
            else
                # Direct server - check exact match
                if echo "$runtime_overrides" | grep -q "^$server$"; then
                    is_runtime_disabled="true"
                fi
            fi
        fi

        if [[ "$is_runtime_disabled" == "true" ]]; then
            # Server is in runtime override list - force stopped status
            runtime_status="stopped"
        elif [[ "$runtime_query_success" == "true" ]]; then
            # Check actual runtime state from claude mcp list
            local found="false"
            if [[ "$server" =~ @ ]]; then
                # Plugin server - extract base name
                local plugin_base
                plugin_base=$(echo "$server" | sed 's/@.*//')
                if echo "$runtime_servers_cache" | grep -q "^plugin:$plugin_base$"; then
                    found="true"
                fi
            else
                # Direct server - match exactly
                if echo "$runtime_servers_cache" | grep -q "^direct:$server$"; then
                    found="true"
                fi
            fi

            if [[ "$found" == "true" ]]; then
                runtime_status="running"
            else
                # Server enabled in config but not running yet - show as GREEN (unknown)
                # Only "stopped" status (from runtime override) should show ORANGE
                runtime_status="unknown"
            fi
        fi
        # else: leave as "unknown" if runtime query failed

        echo "$state:$server:$def_scope:$def_file:$source_type:$flags:$runtime_status" >> "$STATE_FILE"
    done

    # Sort state file by server name
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# ============================================================================
# MIGRATION HELPER FUNCTIONS
# ============================================================================

# Check if server has already been migrated to ./.mcp.json
# Args: $1 - server name
# Returns: 0 if migrated, 1 if not
# Validates actual migration state (not just tracking file)
is_server_migrated() {
    local server="$1"
    local migrations_file="./.claude/.mcp_migrations"
    local cwd=$(pwd)

    # Check if marked as migrated
    if [[ ! -f "$migrations_file" ]] || ! grep -q "^$server:" "$migrations_file" 2>/dev/null; then
        return 1
    fi

    # Validate migration is still valid:
    # 1. Server exists in ./.mcp.json
    # 2. Server does NOT exist in ~/.claude.json (root or projects)

    # Check if server exists in ./.mcp.json
    if [[ -f "./.mcp.json" ]]; then
        if ! jq -e --arg srv "$server" '.mcpServers[$srv]' "./.mcp.json" >/dev/null 2>&1; then
            # Server not in ./.mcp.json, migration invalid
            return 1
        fi
    else
        # No ./.mcp.json file, migration invalid
        return 1
    fi

    # Check if server still exists in ~/.claude.json (shouldn't if migrated)
    if [[ -f "$HOME/.claude.json" ]]; then
        # Check root .mcpServers
        if jq -e --arg srv "$server" '.mcpServers[$srv]' "$HOME/.claude.json" >/dev/null 2>&1; then
            # Server still in ~/.claude.json root, migration invalid
            return 1
        fi

        # Check .projects[cwd].mcpServers
        if jq -e --arg cwd "$cwd" --arg srv "$server" '.projects[$cwd].mcpServers[$srv]' "$HOME/.claude.json" >/dev/null 2>&1; then
            # Server still in ~/.claude.json projects, migration invalid
            return 1
        fi
    fi

    # All checks passed - migration is valid
    return 0
}

# Mark server as migrated
# Args: $1 - server name
mark_server_migrated() {
    local server="$1"
    local migrations_file="./.claude/.mcp_migrations"

    mkdir -p "./.claude"
    echo "$server:$(date +%s)" >> "$migrations_file"
}

# Get server source type from state file
# Args: $1 - server name
# Returns: source type (mcpjson, direct-global, direct-local) or empty
get_server_source_type() {
    local server="$1"

    while IFS=: read -r state srv scope file source_type flags runtime; do
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility
        if [[ "$srv" == "$server" ]]; then
            echo "$source_type"
            return 0
        fi
    done < "$STATE_FILE"

    return 1
}

# Get server definition file and scope from state file
# Args: $1 - server name
# Returns: "scope:file" or empty
get_server_definition_location() {
    local server="$1"

    while IFS=: read -r state srv scope file source_type flags runtime; do
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility
        if [[ "$srv" == "$server" ]]; then
            echo "$scope:$file"
            return 0
        fi
    done < "$STATE_FILE"

    return 1
}

# Extract server definition from source file
# Args: $1 - server name, $2 - source file, $3 - source type
# Returns: JSON definition of server
extract_server_definition() {
    local server="$1"
    local source_file="$2"
    local source_type="$3"
    local cwd=$(pwd)

    if [[ "$source_type" == "direct-global" ]]; then
        # From ~/.claude.json root .mcpServers
        jq -r --arg srv "$server" '.mcpServers[$srv]' "$source_file"
    elif [[ "$source_type" == "direct-local" ]]; then
        # From ~/.claude.json .projects[cwd].mcpServers
        jq -r --arg cwd "$cwd" --arg srv "$server" '.projects[$cwd].mcpServers[$srv]' "$source_file"
    else
        # From .mcp.json file
        jq -r --arg srv "$server" '.mcpServers[$srv]' "$source_file"
    fi
}

# Migrate server from ~/.claude.json to ./.mcp.json
# Args: $1 - server name
# Returns: 0 on success, 1 on failure
migrate_server_to_project_mcpjson() {
    local server="$1"

    # Get server location and source type
    local location source_type def_scope def_file
    location=$(get_server_definition_location "$server")
    if [[ -z "$location" ]]; then
        msg_error "Cannot find server '$server' in state"
        return 1
    fi

    def_scope=$(echo "$location" | cut -d: -f1)
    def_file=$(echo "$location" | cut -d: -f2-)
    source_type=$(get_server_source_type "$server")

    # Only migrate if it's a direct server
    if [[ "$source_type" != "direct-global" ]] && [[ "$source_type" != "direct-local" ]]; then
        msg_error "Server '$server' is not a direct server (type: $source_type)"
        return 1
    fi

    msg_info "Migrating '$server' to ./.mcp.json for project-level control..."
    echo ""

    # Create backup of ~/.claude.json in dedicated backup directory
    mkdir -p "$BACKUP_DIR"
    local backup_file="$BACKUP_DIR/claude.json.backup.$(date +%Y%m%d_%H%M%S)"
    if ! cp "$def_file" "$backup_file" 2>/dev/null; then
        msg_error "Failed to create backup of $def_file"
        return 1
    fi
    msg_info "Backup created: $backup_file"

    # Cleanup old backups in background (keep last 5) - non-blocking
    (
        local backup_count
        if command -v fd &> /dev/null; then
            backup_count=$(fd -t f "claude.json.backup." "$BACKUP_DIR" 2>/dev/null | wc -l)
            if [[ $backup_count -gt 5 ]]; then
                fd -t f "claude.json.backup." "$BACKUP_DIR" 2>/dev/null | sort | head -n -5 | xargs rm -f 2>/dev/null || true
            fi
        else
            # Fallback to find if fd is not available
            backup_count=$(find "$BACKUP_DIR" -type f -name "claude.json.backup.*" 2>/dev/null | wc -l)
            if [[ $backup_count -gt 5 ]]; then
                find "$BACKUP_DIR" -type f -name "claude.json.backup.*" 2>/dev/null | sort | head -n -5 | xargs rm -f 2>/dev/null || true
            fi
        fi
    ) &

    # Extract server definition
    local definition
    definition=$(extract_server_definition "$server" "$def_file" "$source_type")
    if [[ -z "$definition" ]] || [[ "$definition" == "null" ]]; then
        msg_error "Failed to extract server definition"
        rm "$backup_file"
        return 1
    fi

    # Create ./.mcp.json if it doesn't exist
    if [[ ! -f "./.mcp.json" ]]; then
        echo '{"mcpServers":{}}' > "./.mcp.json"
        msg_info "Created ./.mcp.json"
    fi

    # Add to ./.mcp.json (atomic operation)
    local temp_dest=$(mktemp)
    if ! jq --arg srv "$server" --argjson def "$definition" \
        '.mcpServers[$srv] = $def' "./.mcp.json" > "$temp_dest" 2>/dev/null; then
        msg_error "Failed to add server to ./.mcp.json"
        rm "$temp_dest" "$backup_file"
        return 1
    fi
    mv "$temp_dest" "./.mcp.json"
    msg_success "Added to ./.mcp.json"

    # Remove from ~/.claude.json (atomic operation)
    local temp_src=$(mktemp)
    local cwd=$(pwd)

    if [[ "$source_type" == "direct-global" ]]; then
        # Remove from root .mcpServers
        if ! jq --arg srv "$server" 'del(.mcpServers[$srv])' "$def_file" > "$temp_src" 2>/dev/null; then
            msg_error "Failed to remove server from $def_file"
            rm "$temp_src" "$backup_file"
            return 1
        fi
    elif [[ "$source_type" == "direct-local" ]]; then
        # Remove from .projects[cwd].mcpServers
        if ! jq --arg cwd "$cwd" --arg srv "$server" \
            'del(.projects[$cwd].mcpServers[$srv])' "$def_file" > "$temp_src" 2>/dev/null; then
            msg_error "Failed to remove server from $def_file"
            rm "$temp_src" "$backup_file"
            return 1
        fi
    fi

    # Validate both JSON files
    if ! jq empty "$temp_src" 2>/dev/null || ! jq empty "./.mcp.json" 2>/dev/null; then
        msg_error "JSON validation failed, rolling back"
        mv "$backup_file" "$def_file"
        rm "$temp_src"
        return 1
    fi

    mv "$temp_src" "$def_file"
    msg_success "Removed from $def_file"

    # Mark as migrated
    mark_server_migrated "$server"

    echo ""
    msg_success "Migration complete!"
    msg_info "Server '$server' can now be controlled via project settings"
    echo ""

    return 0
}

# Prompt user for migration with interactive options
# Args: $1 - server name, $2 - source type, $3 - source file
# Returns: 0 if user wants to migrate, 1 if not
prompt_for_migration() {
    local server="$1"
    local source_type="$2"
    local source_file="$3"

    # Redirect stdin and stdout to tty to show prompts in fzf context
    exec < /dev/tty > /dev/tty

    echo ""
    echo ""
    echo ""
    echo -e "${COLOR_YELLOW}═══════════════════════════════════════════════════${COLOR_RESET}"
    echo -e "${COLOR_WHITE}  Migration Required: ${COLOR_CYAN}$server${COLOR_RESET}"
    echo -e "${COLOR_YELLOW}═══════════════════════════════════════════════════${COLOR_RESET}"
    echo ""
    echo "This server is defined in:"
    echo -e "  ${COLOR_CYAN}$source_file${COLOR_RESET}"
    echo ""
    echo -e "Servers in this location are ${COLOR_RED}ALWAYS ENABLED${COLOR_RESET}."
    echo ""
    echo "To disable it, this tool must:"
    echo -e "  ${COLOR_GREEN}1.${COLOR_RESET} MOVE definition → ${COLOR_CYAN}./.mcp.json${COLOR_RESET} (project)"
    echo -e "  ${COLOR_GREEN}2.${COLOR_RESET} REMOVE from → ${COLOR_CYAN}$source_file${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}3.${COLOR_RESET} Disable via → ${COLOR_CYAN}./.claude/settings.local.json${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_YELLOW}⚠ This MODIFIES your global config!${COLOR_RESET}"
    echo -e "  (A timestamped backup will be created first)"
    echo ""
    echo -e "${COLOR_WHITE}What would you like to do?${COLOR_RESET}"
    echo ""
    echo -e "  ${COLOR_GREEN}[y] Yes - Migrate and disable${COLOR_RESET}"
    echo "      • Performs all 3 steps above automatically"
    echo "      • Server becomes controllable in this project"
    echo "      • Server will be DISABLED after migration"
    echo "      • Global config is modified (backup created)"
    echo -e "      • ${COLOR_CYAN}Recommended if you want project-level control${COLOR_RESET}"
    echo ""
    echo -e "  ${COLOR_BLUE}[v] View - Show server definition${COLOR_RESET}"
    echo "      • Displays the full JSON configuration"
    echo "      • Helps you understand what will be migrated"
    echo "      • You can decide after viewing"
    echo "      • No changes made until you confirm"
    echo ""
    echo -e "  ${COLOR_RED}[n] No - Keep enabled globally${COLOR_RESET}"
    echo "      • Cancels migration process"
    echo "      • Server remains in $source_file"
    echo "      • Server stays ALWAYS ENABLED"
    echo "      • No changes made to any files"
    echo ""

    while true; do
        read -rp "Your choice [y/v/n]: " choice
        case "$choice" in
            y|Y)
                return 0
                ;;
            v|V)
                # Show definition
                echo ""
                echo -e "${COLOR_CYAN}Server Definition:${COLOR_RESET}"
                echo ""
                extract_server_definition "$server" "$source_file" "$source_type" | jq .
                echo ""
                read -rp "Migrate this to ./.mcp.json? [y/n]: " confirm
                if [[ "$confirm" =~ ^[Yy]$ ]]; then
                    return 0
                else
                    return 1
                fi
                ;;
            n|N)
                msg_warning "Migration cancelled - server will remain enabled"
                sleep 1
                return 1
                ;;
            *)
                echo -e "${COLOR_RED}Invalid choice. Please enter y, v, or n${COLOR_RESET}"
                ;;
        esac
    done
}

# Show toggle error message (helper for enterprise validation)
# Args: $1 - title, $2 - reason, $3 - action
show_toggle_error() {
    local title="$1"
    local reason="$2"
    local action="$3"

    # Redirect to tty for visibility
    exec < /dev/tty > /dev/tty

    echo ""
    echo -e "${COLOR_RED}${MARK_ERROR} ${title}${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_YELLOW}${reason}${COLOR_RESET}"
    echo -e "${COLOR_CYAN}${action}${COLOR_RESET}"
    echo ""
    sleep 2  # Give user time to read
}

# Add server to ~/.claude.json .projects[cwd].disabledMcpServers
# Args: $1 - server name, $2 - source type (plugin/mcpjson/direct-global/direct-local)
add_to_disabled_mcp_servers() {
    local server="$1"
    local source_type="$2"
    local cwd=$(pwd)
    local claude_json="$HOME/.claude.json"

    # Backup ~/.claude.json
    local backup_file="$BACKUP_DIR/claude.json.$(date +%Y%m%d_%H%M%S).bak"
    mkdir -p "$BACKUP_DIR"
    if ! cp "$claude_json" "$backup_file" 2>/dev/null; then
        msg_error "Failed to backup ~/.claude.json"
        return 1
    fi

    local temp_json=$(mktemp)

    # Plugin servers use special format: plugin:mcp-NAME:KEY
    if [[ "$source_type" == "plugin" ]] && [[ "$server" =~ @ ]]; then
        local plugin_base=$(echo "$server" | sed 's/@.*//')
        local plugin_key=$(echo "$plugin_base" | sed 's/^mcp-//')

        if ! jq --arg cwd "$cwd" --arg plugin_base "$plugin_base" --arg plugin_key "$plugin_key" '
            .projects //= {} | .projects[$cwd] //= {} |
            .projects[$cwd].disabledMcpServers = (
                [.projects[$cwd].disabledMcpServers[]? // empty] +
                ["plugin:\($plugin_base):\($plugin_key)"]
            ) | unique
        ' "$claude_json" > "$temp_json" 2>/dev/null; then
            msg_error "Failed to add plugin to disabledMcpServers"
            rm -f "$temp_json"
            return 1
        fi
    else
        # Direct and MCPJSON servers use plain server name
        if ! jq --arg cwd "$cwd" --arg server "$server" '
            .projects //= {} | .projects[$cwd] //= {} |
            .projects[$cwd].disabledMcpServers = (
                [.projects[$cwd].disabledMcpServers[]? // empty] +
                [$server]
            ) | unique
        ' "$claude_json" > "$temp_json" 2>/dev/null; then
            msg_error "Failed to add server to disabledMcpServers"
            rm -f "$temp_json"
            return 1
        fi
    fi

    # Validate JSON
    if ! jq empty "$temp_json" 2>/dev/null; then
        msg_error "Failed to update ~/.claude.json - invalid JSON"
        rm -f "$temp_json"
        return 1
    fi

    mv "$temp_json" "$claude_json"
    msg_success "Added to runtime override list (will show ORANGE)"
    sleep 0.3
    return 0
}

# Remove server from ~/.claude.json .projects[cwd].disabledMcpServers
# Args: $1 - server name, $2 - source type (plugin/mcpjson/direct-global/direct-local)
remove_from_disabled_mcp_servers() {
    local server="$1"
    local source_type="$2"
    local cwd=$(pwd)
    local claude_json="$HOME/.claude.json"

    # Backup ~/.claude.json
    local backup_file="$BACKUP_DIR/claude.json.$(date +%Y%m%d_%H%M%S).bak"
    mkdir -p "$BACKUP_DIR"
    if ! cp "$claude_json" "$backup_file" 2>/dev/null; then
        msg_error "Failed to backup ~/.claude.json"
        return 1
    fi

    local temp_json=$(mktemp)

    # Plugin servers use special format: plugin:mcp-NAME:KEY
    if [[ "$source_type" == "plugin" ]] && [[ "$server" =~ @ ]]; then
        local plugin_base=$(echo "$server" | sed 's/@.*//')

        if ! jq --arg cwd "$cwd" --arg plugin_base "$plugin_base" '
            .projects //= {} | .projects[$cwd] //= {} |
            .projects[$cwd].disabledMcpServers = [
                .projects[$cwd].disabledMcpServers[]? // empty |
                select(
                    if startswith("plugin:") then
                        split(":")[1] != $plugin_base
                    else
                        true
                    end
                )
            ]
        ' "$claude_json" > "$temp_json" 2>/dev/null; then
            msg_error "Failed to remove plugin from disabledMcpServers"
            rm -f "$temp_json"
            return 1
        fi
    else
        # Direct and MCPJSON servers use plain server name
        if ! jq --arg cwd "$cwd" --arg server "$server" '
            .projects //= {} | .projects[$cwd] //= {} |
            .projects[$cwd].disabledMcpServers = [
                .projects[$cwd].disabledMcpServers[]? // empty |
                select(. != $server)
            ]
        ' "$claude_json" > "$temp_json" 2>/dev/null; then
            msg_error "Failed to remove server from disabledMcpServers"
            rm -f "$temp_json"
            return 1
        fi
    fi

    # Validate JSON
    if ! jq empty "$temp_json" 2>/dev/null; then
        msg_error "Failed to update ~/.claude.json - invalid JSON"
        rm -f "$temp_json"
        return 1
    fi

    mv "$temp_json" "$claude_json"
    msg_success "Removed from runtime override list"
    sleep 0.3
    return 0
}

# ============================================================================
# FILTER FUNCTIONS
# ============================================================================

# Set filter to show only MCPJSON servers
set_filter_mcpjson() {
    FILTER_TYPE="mcpjson"
    echo "Filter: MCPJSON servers" >&2
}

# Set filter to show only Direct servers
set_filter_direct() {
    FILTER_TYPE="direct"
    echo "Filter: Direct servers" >&2
}

# Set filter to show only Plugin servers
set_filter_plugin() {
    FILTER_TYPE="plugin"
    echo "Filter: Plugin servers" >&2
}

# Set filter to show only Enterprise servers
set_filter_enterprise() {
    FILTER_TYPE="enterprise"
    echo "Filter: Enterprise servers" >&2
}

# Set filter to show only Blocked/Restricted servers
set_filter_blocked() {
    FILTER_TYPE="blocked"
    echo "Filter: Blocked/Restricted servers" >&2
}

# Set filter to show only ORANGE (runtime-disabled) servers
set_filter_orange() {
    FILTER_TYPE="orange"
    echo "Filter: Runtime-disabled (ORANGE) servers" >&2
}

# Reset filter to show all servers
set_filter_all() {
    FILTER_TYPE="all"
    echo "Filter: All servers" >&2
}

# ============================================================================
# HARD DISABLE PLUGIN
# ============================================================================

# Hard disable a plugin (sets explicit false in enabledPlugins)
# This makes the plugin completely hidden from Claude UI
# Args: $1 - raw input from fzf (contains server name)
hard_disable_plugin() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    # Get server metadata from state file
    local source_type=""
    while IFS=: read -r state srv scope file stype flags runtime; do
        if [[ "$srv" == "$server" ]]; then
            source_type="$stype"
            break
        fi
    done < "$STATE_FILE"

    # Only works for plugins
    if [[ "$source_type" != "plugin" ]]; then
        echo -e "${COLOR_YELLOW}${MARK_WARNING} ALT-H only works for plugin servers${COLOR_RESET}" >&2
        echo -e "  Server '$server' is type: $source_type" >&2
        sleep 1.5
        return 1
    fi

    # Show warning
    clear
    echo ""
    echo -e "${COLOR_RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}"
    echo -e "${COLOR_RED}⚠️  HARD DISABLE WARNING${COLOR_RESET}"
    echo -e "${COLOR_RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}"
    echo ""
    echo -e "You are about to HARD DISABLE plugin: ${COLOR_CYAN}$server${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_YELLOW}This will:${COLOR_RESET}"
    echo -e "  • Set enabledPlugins['$server'] = false"
    echo -e "  • Make the plugin ${COLOR_RED}INVISIBLE${COLOR_RESET} in Claude's /mcp list"
    echo -e "  • Prevent re-enabling via Claude UI"
    echo ""
    echo -e "${COLOR_YELLOW}To recover, you will need to:${COLOR_RESET}"
    echo -e "  • Run: ./mcp --restore-plugin '$server'"
    echo -e "  • Or manually edit the config file"
    echo ""
    echo -n "Are you sure? [y/N] "
    read -r response

    if [[ ! "$response" =~ ^[Yy] ]]; then
        echo -e "${COLOR_GREY}Cancelled${COLOR_RESET}"
        sleep 0.5
        return 0
    fi

    # Apply hard disable
    local settings_file="./.claude/settings.local.json"
    mkdir -p "./.claude"

    if [[ ! -f "$settings_file" ]]; then
        echo '{}' > "$settings_file"
    fi

    # Create backup
    mkdir -p "$BACKUP_DIR"
    cp "$settings_file" "$BACKUP_DIR/$(basename "$settings_file").backup.$(date +%s)"

    # Add explicit false to enabledPlugins
    local temp_file
    temp_file=$(mktemp)
    jq --arg plugin "$server" '
        .enabledPlugins //= {} |
        .enabledPlugins[$plugin] = false
    ' "$settings_file" > "$temp_file"
    mv "$temp_file" "$settings_file"

    # Update state file to reflect disabled state
    temp_file=$(mktemp)
    while IFS=: read -r state srv scope file stype flags runtime; do
        if [[ "$srv" == "$server" ]]; then
            echo "off:$srv:$scope:$file:$stype:$flags:stopped"
        else
            echo "$state:$srv:$scope:$file:$stype:$flags:$runtime"
        fi
    done < "$STATE_FILE" > "$temp_file"
    mv "$temp_file" "$STATE_FILE"

    echo -e "${COLOR_GREEN}${MARK_SUCCESS} Plugin hard-disabled${COLOR_RESET}"
    echo -e "  To restore: ./mcp --restore-plugin '$server'"
    sleep 1.5
    return 0
}

# Toggle server state in state file
# Args: $1 - server name (may have prefix like "[ON ] server-name (scope)")
# NEW: Direct servers now toggle normally (quick-disable)
# NEW: Enterprise validation prevents toggling restricted servers
toggle_server() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    # Get server metadata from state file for validation
    local server_flags=""
    local current_state=""
    local server_scope=""

    while IFS=: read -r state srv scope file stype flags runtime; do
        [[ -z "$flags" ]] && flags=""
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility
        if [[ "$srv" == "$server" ]]; then
            server_flags="$flags"
            current_state="$state"
            server_scope="$scope"
            break
        fi
    done < "$STATE_FILE"

    # === ENTERPRISE VALIDATION (Phase 5) ===

    # Check 1: Enterprise-managed servers cannot be toggled
    if [[ "$server_flags" == *"e"* ]]; then
        show_toggle_error \
            "Cannot modify enterprise-managed server" \
            "This server is managed by your IT department." \
            "Contact your administrator to request changes."
        return 1
    fi

    # Check 2: Cannot enable blocked servers (denylist)
    if [[ "$server_flags" == *"b"* ]] && [[ "$current_state" == "off" ]]; then
        show_toggle_error \
            "Cannot enable blocked server" \
            "This server is blocked by enterprise policy." \
            "Contact your administrator if you need access."
        return 1
    fi

    # Check 3: Cannot enable restricted servers (not in allowlist)
    if [[ "$server_flags" == *"r"* ]] && [[ "$current_state" == "off" ]]; then
        show_toggle_error \
            "Cannot enable restricted server" \
            "This server is not in the approved list." \
            "Contact your administrator to request access."
        return 1
    fi

    # === END ENTERPRISE VALIDATION ===

    # === 3-WAY TOGGLE LOGIC (RED → GREEN → ORANGE → RED) ===
    # RED: state==off (disabled in config)
    # GREEN: state==on, not in disabledMcpServers (enabled, will run)
    # ORANGE: state==on, IN disabledMcpServers (enabled in config, runtime disabled)

    local runtime_status=""
    local source_type=""
    while IFS=: read -r state srv scope file stype flags runtime; do
        [[ -z "$runtime" ]] && runtime="unknown"
        if [[ "$srv" == "$server" ]]; then
            runtime_status="$runtime"
            source_type="$stype"
            break
        fi
    done < "$STATE_FILE"

    # Check ~/.claude.json exists and is valid
    local cwd=$(pwd)
    local claude_json="$HOME/.claude.json"

    if [[ ! -f "$claude_json" ]]; then
        msg_error "~/.claude.json not found - cannot use runtime overrides"
        # Fall back to simple toggle
        local temp_state=$(mktemp)
        while IFS=: read -r state srv scope file stype flags runtime; do
            [[ -z "$flags" ]] && flags=""
            [[ -z "$runtime" ]] && runtime="unknown"
            if [[ "$srv" == "$server" ]]; then
                if [[ "$state" == "on" ]]; then
                    echo "off:$srv:$scope:$file:$stype:$flags:$runtime" >> "$temp_state"
                else
                    echo "on:$srv:$scope:$file:$stype:$flags:unknown" >> "$temp_state"
                fi
            else
                echo "$state:$srv:$scope:$file:$stype:$flags:$runtime" >> "$temp_state"
            fi
        done < "$STATE_FILE"
        mv "$temp_state" "$STATE_FILE"
        return 0
    fi

    # Determine current position in toggle cycle
    # Check if server is in disabledMcpServers
    local in_disabled=""
    if [[ "$source_type" == "plugin" ]]; then
        # Plugin servers use special format: plugin:mcp-NAME:KEY
        if [[ "$server" =~ @ ]]; then
            local plugin_base=$(echo "$server" | sed 's/@.*//')
            in_disabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers[]? // empty | select(startswith("plugin:"))' "$claude_json" 2>/dev/null | grep -F "$plugin_base" || true)
        fi
    else
        # Direct and MCPJSON servers use plain server name
        in_disabled=$(jq -r --arg cwd "$cwd" --arg server "$server" '.projects[$cwd].disabledMcpServers[]? // empty | select(. == $server)' "$claude_json" 2>/dev/null || true)
    fi

    # Determine transition based on current state
    if [[ "$current_state" == "off" ]]; then
        # RED → GREEN: Turn on, ensure not in disabledMcpServers
        local temp_state=$(mktemp)
        while IFS=: read -r state srv scope file stype flags runtime; do
            [[ -z "$flags" ]] && flags=""
            [[ -z "$runtime" ]] && runtime="unknown"
            if [[ "$srv" == "$server" ]]; then
                echo "on:$srv:$scope:$file:$stype:$flags:unknown" >> "$temp_state"
            else
                echo "$state:$srv:$scope:$file:$stype:$flags:$runtime" >> "$temp_state"
            fi
        done < "$STATE_FILE"
        mv "$temp_state" "$STATE_FILE"

        # Also remove from disabledMcpServers if present
        if [[ -n "$in_disabled" ]]; then
            remove_from_disabled_mcp_servers "$server" "$source_type"
        fi

        return 0

    elif [[ "$current_state" == "on" ]] && [[ -z "$in_disabled" ]]; then
        # GREEN → ORANGE: Keep on, add to disabledMcpServers
        add_to_disabled_mcp_servers "$server" "$source_type"

        # Update state file to show stopped
        local temp_state=$(mktemp)
        while IFS=: read -r state srv scope file stype flags runtime; do
            [[ -z "$flags" ]] && flags=""
            [[ -z "$runtime" ]] && runtime="unknown"
            if [[ "$srv" == "$server" ]]; then
                echo "on:$srv:$scope:$file:$stype:$flags:stopped" >> "$temp_state"
            else
                echo "$state:$srv:$scope:$file:$stype:$flags:$runtime" >> "$temp_state"
            fi
        done < "$STATE_FILE"
        mv "$temp_state" "$STATE_FILE"

        return 0

    elif [[ "$current_state" == "on" ]] && [[ -n "$in_disabled" ]]; then
        # ORANGE → RED: Turn off, remove from disabledMcpServers
        local temp_state=$(mktemp)
        while IFS=: read -r state srv scope file stype flags runtime; do
            [[ -z "$flags" ]] && flags=""
            [[ -z "$runtime" ]] && runtime="unknown"
            if [[ "$srv" == "$server" ]]; then
                echo "off:$srv:$scope:$file:$stype:$flags:$runtime" >> "$temp_state"
            else
                echo "$state:$srv:$scope:$file:$stype:$flags:$runtime" >> "$temp_state"
            fi
        done < "$STATE_FILE"
        mv "$temp_state" "$STATE_FILE"

        # Remove from disabledMcpServers
        remove_from_disabled_mcp_servers "$server" "$source_type"

        return 0
    fi

    # Fallback: shouldn't reach here
    return 1
}

# Add new server to state file (disabled by default, local scope, mcpjson type)
# Args: $1 - server name
# Note: Added servers are placeholders - user must define them in .mcp.json manually
add_server() {
    local server="$1"

    # Validate server name (alphanumeric, dashes, underscores)
    if [[ ! "$server" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        msg_error "Invalid server name. Use only alphanumeric characters, dashes, and underscores."
        return 1
    fi

    # Check for duplicates (check column 2 for server name)
    if grep -q "^[^:]*:$server:" "$STATE_FILE" 2>/dev/null; then
        msg_warning "Server '$server' already exists"
        return 1
    fi

    # Add to state file (disabled, project scope, .mcp.json, mcpjson type, no flags)
    # Note: This assumes user will define the server in ./.mcp.json
    echo "off:$server:project:./.mcp.json:mcpjson:" >> "$STATE_FILE"
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# Remove server from state file
# Args: $1 - server name (may have prefix and scope suffix)
remove_server() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    # Remove from state file (match server name in column 2)
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type flags runtime; do
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility
        if [[ "$srv" != "$server" ]]; then
            echo "$state:$srv:$scope:$file:$source_type:$flags:$runtime" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Enable all servers in state file (preserve scope, file, source type, flags, and runtime metadata)
enable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type flags runtime; do
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility
        echo "on:$srv:$scope:$file:$source_type:$flags:$runtime" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Disable all servers in state file (preserve scope, file, source type, flags, and runtime metadata)
disable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type flags runtime; do
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility
        echo "off:$srv:$scope:$file:$source_type:$flags:$runtime" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Get plugin value from project-level settings file
# Args: $1 - plugin server name (e.g., "mcp-fetch@claudecode-marketplace")
# Returns: "true", "false", or "unset"
get_project_plugin_value() {
    local plugin="$1"
    local project_settings="./.claude/settings.json"

    if [[ ! -f "$project_settings" ]]; then
        echo "unset"
        return
    fi

    local value
    value=$(jq -r --arg plugin "$plugin" 'if .enabledPlugins | has($plugin) then .enabledPlugins[$plugin] else "unset" end' "$project_settings" 2>/dev/null)
    echo "$value"
}

# Check if a plugin is enabled in any lower-priority scope
# Args: $1 - plugin server name (e.g., "mcp-fetch@claudecode-marketplace")
#       $2 - cached all_sources output (optional, will fetch if not provided)
# Returns: 0 if plugin is enabled in lower-priority scope, 1 if not
# This is used to decide: write explicit false (override) vs omit (avoid UI disappearance)
plugin_enabled_in_lower_scope() {
    local plugin="$1"
    local all_sources="${2:-}"
    local target_scope="local"  # We write to local scope
    local target_priority
    target_priority=$(get_scope_priority "$target_scope")

    # Use cached sources if provided, otherwise fetch (for backward compat)
    if [[ -z "$all_sources" ]]; then
        all_sources=$(discover_and_parse_all_sources)
    fi

    while IFS=: read -r type srv scope file; do
        [[ "$srv" != "$plugin" ]] && continue
        [[ "$type" != "enable" ]] && continue

        local priority
        priority=$(get_scope_priority "$scope")

        # If this enable directive has lower priority than our target, return true
        if [[ $priority -lt $target_priority ]]; then
            return 0
        fi
    done <<< "$all_sources"

    return 1
}

# Save state file to project-local settings only (./.claude/settings.local.json)
# Never modifies global user settings
save_state_to_settings() {
    local target="./.claude/settings.local.json"

    # Create .claude directory if it doesn't exist
    if [[ ! -d "./.claude" ]]; then
        mkdir -p "./.claude"
        msg_info "Created .claude/ directory"
    fi

    # PERFORMANCE: Cache config sources once for all plugin checks (avoid parsing 7 files repeatedly)
    local cached_sources
    cached_sources=$(discover_and_parse_all_sources)

    # Parse state file into categories
    local enabled_mcpjson=()
    local disabled_mcpjson=()
    local disabled_direct=()  # Track Direct servers separately
    declare -A enabled_plugins  # Track plugin servers (name -> state)

    while IFS=: read -r state server scope file source_type flags runtime; do
        [[ -z "$server" ]] && continue
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility

        # === ORANGE STATE HANDLING (ALL SERVER TYPES) ===
        # Servers with runtime==stopped are in ORANGE state (enabled but runtime-disabled)
        # These MUST be added to disabledMcpServers in ~/.claude.json
        if [[ "$runtime" == "stopped" ]]; then
            if [[ "$source_type" == "plugin" ]]; then
                # Plugins use special format: plugin:mcp-NAME:KEY
                local plugin_base=$(echo "$server" | sed 's/@.*//')
                local plugin_key=$(echo "$plugin_base" | sed 's/^mcp-//')
                disabled_direct+=("plugin:$plugin_base:$plugin_key")
            else
                # MCPJSON and Direct servers use plain name
                disabled_direct+=("$server")
            fi
        fi

        # === HANDLE EACH SERVER TYPE ===
        # Handle Direct servers separately
        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            # RED Direct servers also go in disabledMcpServers (if not already added as ORANGE)
            if [[ "$state" == "off" ]] && [[ "$runtime" != "stopped" ]]; then
                disabled_direct+=("$server")
            fi
            continue
        fi

        # Handle Plugin servers with smart precedence-aware strategy
        if [[ "$source_type" == "plugin" ]]; then
            if [[ "$state" == "on" ]]; then
                # Plugin is enabled - write explicit true
                enabled_plugins["$server"]="true"
            else
                # Plugin is disabled - check if we need explicit false or omit
                if plugin_enabled_in_lower_scope "$server" "$cached_sources"; then
                    # Plugin is enabled at lower-priority scope (e.g., project/user)
                    # Write explicit false to override it
                    enabled_plugins["$server"]="false"
                fi
                # Otherwise omit (plugin not enabled elsewhere, avoid UI disappearance)
            fi
            continue
        fi

        # MCPJSON servers
        # CRITICAL: Don't add ORANGE servers to enabled/disabled arrays
        # ORANGE servers (state==on, runtime==stopped) are controlled ONLY via disabledMcpServers
        if [[ "$state" == "on" ]] && [[ "$runtime" != "stopped" ]]; then
            # GREEN servers only (will run)
            enabled_mcpjson+=("$server")
        elif [[ "$state" == "off" ]]; then
            # RED servers only (won't run)
            disabled_mcpjson+=("$server")
        fi
        # ORANGE servers: neither enabled nor disabled in MCPJSON arrays
        # They're in disabledMcpServers, which provides runtime override
    done < "$STATE_FILE"

    # Build JSON arrays for MCPJSON servers
    local enabled_json
    local disabled_json

    if [[ ${#enabled_mcpjson[@]} -eq 0 ]]; then
        enabled_json="[]"
    else
        enabled_json=$(printf '%s\n' "${enabled_mcpjson[@]}" | jq -R . | jq -s -c .)
    fi

    if [[ ${#disabled_mcpjson[@]} -eq 0 ]]; then
        disabled_json="[]"
    else
        disabled_json=$(printf '%s\n' "${disabled_mcpjson[@]}" | jq -R . | jq -s -c .)
    fi

    # Initialize with empty object if file doesn't exist
    if [[ ! -f "$target" ]]; then
        echo '{}' > "$target"
        msg_info "Created $target"
    fi

    # Build enabledPlugins JSON object (with redundancy elimination)
    local plugins_json="{}"
    # Safe check for non-empty associative array with set -u
    local plugin_count=0
    for _ in "${!enabled_plugins[@]}"; do ((plugin_count++)); done

    if [[ $plugin_count -gt 0 ]]; then
        # Filter out redundant entries that match project-level values
        declare -A filtered_plugins
        for plugin in "${!enabled_plugins[@]}"; do
            local our_value="${enabled_plugins[$plugin]}"
            local project_value
            project_value=$(get_project_plugin_value "$plugin")

            # Only write if:
            # 1. Value differs from project (override needed), OR
            # 2. Value is false and project is unset (explicit override of lower-priority enable)
            if [[ "$our_value" != "$project_value" ]]; then
                filtered_plugins["$plugin"]="$our_value"
            fi
            # Skip if our_value == project_value (redundant)
        done

        # Build JSON from filtered plugins
        local filtered_count=0
        for _ in "${!filtered_plugins[@]}"; do ((filtered_count++)); done

        if [[ $filtered_count -gt 0 ]]; then
            plugins_json="{"
            local first=true
            for plugin in "${!filtered_plugins[@]}"; do
                if [[ "$first" == "true" ]]; then
                    first=false
                else
                    plugins_json+=","
                fi
                plugins_json+="\"$plugin\":${filtered_plugins[$plugin]}"
            done
            plugins_json+="}"
        fi
    fi

    # Atomic update for MCPJSON servers and plugins
    local temp_file
    temp_file=$(mktemp)

    jq --argjson enabled "$enabled_json" \
       --argjson disabled "$disabled_json" \
       --argjson plugins "$plugins_json" \
       '.enabledMcpjsonServers = $enabled | .disabledMcpjsonServers = $disabled | .enabledPlugins = $plugins' \
       "$target" > "$temp_file"

    mv "$temp_file" "$target"

    # Write to ~/.claude.json .projects[cwd].disabledMcpServers
    # This includes:
    # 1. ORANGE servers (runtime==stopped) - all types with special plugin format
    # 2. RED Direct servers (state==off)
    # Always call this to ensure the list is updated (even if empty)
    if [[ ${#disabled_direct[@]} -gt 0 ]]; then
        write_direct_servers_to_claude_json "${disabled_direct[@]}"
    else
        # No servers in disabledMcpServers - write empty array
        write_direct_servers_to_claude_json
    fi
}

# ============================================================================
# DIRECT SERVER WRITE FUNCTIONS
# ============================================================================

# Write disabled Direct servers to ~/.claude.json .projects[cwd].disabledMcpServers
# Args: Array of server names to disable
# Returns: 0 on success, 1 on failure
write_direct_servers_to_claude_json() {
    local -a disabled_direct=("$@")
    local target="$HOME/.claude.json"
    local cwd=$(pwd)

    # Check if file exists first
    if [[ ! -f "$target" ]]; then
        msg_error "$target not found"
        return 1
    fi

    # Build the new disabledMcpServers array
    local disabled_json
    if [[ ${#disabled_direct[@]} -eq 0 ]]; then
        disabled_json="[]"
    else
        disabled_json=$(printf '%s\n' "${disabled_direct[@]}" | jq -R . | jq -s -c .)
    fi

    # Quick check: compare what we're about to write with what's already there
    # This avoids expensive temp file creation and hash calculation when no changes needed
    local current_disabled
    current_disabled=$(jq -c --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers // []' "$target" 2>/dev/null)

    if [[ "$current_disabled" == "$disabled_json" ]]; then
        # Already matches - no changes needed
        return 0
    fi

    # Content will change - now create temp preview for atomic write
    local temp_preview=$(mktemp)

    # Write new content to temp file
    # Ensure .projects and .projects[$cwd] exist before setting disabledMcpServers
    if ! jq --arg cwd "$cwd" --argjson disabled "$disabled_json" \
       '.projects //= {} | .projects[$cwd] //= {} | .projects[$cwd].disabledMcpServers = $disabled' \
       "$target" > "$temp_preview" 2>/dev/null; then
        msg_error "Failed to write changes to temp file"
        rm -f "$temp_preview"
        return 1
    fi

    # Validate JSON before proceeding
    if ! jq empty "$temp_preview" 2>/dev/null; then
        msg_error "JSON validation failed"
        rm -f "$temp_preview"
        return 1
    fi

    # Create backup now that we know changes are needed and valid
    mkdir -p "$BACKUP_DIR"
    local backup="$BACKUP_DIR/claude.json.backup.$(date +%Y%m%d_%H%M%S)"

    if ! cp "$target" "$backup" 2>/dev/null; then
        msg_error "Failed to create backup of $target"
        rm -f "$temp_preview"
        return 1
    fi

    # Cleanup old backups in background (keep last 5) - non-blocking
    (
        local backup_count
        if command -v fd &> /dev/null; then
            backup_count=$(fd -t f "claude.json.backup." "$BACKUP_DIR" 2>/dev/null | wc -l)
            if [[ $backup_count -gt 5 ]]; then
                fd -t f "claude.json.backup." "$BACKUP_DIR" 2>/dev/null | sort | head -n -5 | xargs rm -f 2>/dev/null || true
            fi
        else
            # Fallback to find if fd is not available
            backup_count=$(find "$BACKUP_DIR" -type f -name "claude.json.backup.*" 2>/dev/null | wc -l)
            if [[ $backup_count -gt 5 ]]; then
                find "$BACKUP_DIR" -type f -name "claude.json.backup.*" 2>/dev/null | sort | head -n -5 | xargs rm -f 2>/dev/null || true
            fi
        fi
    ) &

    # Atomic update - move temp file to target
    mv "$temp_preview" "$target"
    msg_success "Updated $target"

    return 0
}

# ============================================================================
# TUI GENERATION FUNCTIONS
# ============================================================================

# Generate table header with proper column alignment
# Returns: formatted header string matching the data columns
generate_table_header() {
    if [[ ! -f "$STATE_FILE" ]] || [[ ! -s "$STATE_FILE" ]]; then
        echo "  MCP Server              │  Source     │  Scope"
        return
    fi

    # Calculate same column widths as generate_fzf_list
    local max_server_len=0
    local max_type_len=0

    while IFS=: read -r state server scope file source_type flags runtime; do
        [[ -z "$server" ]] && continue
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility

        local server_len=${#server}
        local type_len=0

        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            type_len=6  # "direct"
        elif [[ "$source_type" == "plugin" ]]; then
            type_len=6  # "plugin"
        else
            type_len=7  # "mcpjson"
        fi

        [[ $server_len -gt $max_server_len ]] && max_server_len=$server_len
        [[ $type_len -gt $max_type_len ]] && max_type_len=$type_len
    done < "$STATE_FILE"

    # Add padding (same as generate_fzf_list)
    max_server_len=$((max_server_len + 2))
    max_type_len=$((max_type_len + 2))

    # Build header with same spacing as data rows
    local header_text="MCP Server"
    local source_text="Source"
    local scope_text="Scope"

    local server_padding=$((max_server_len - ${#header_text}))
    local type_padding=$((max_type_len - ${#source_text}))

    # Format: "  " (for symbol space) + "MCP Server" + padding + "│  " + "Source" + padding + "│  " + "Scope"
    local header="  ${header_text}"
    header+="$(printf '%*s' $server_padding '')"
    header+="│  ${source_text}"
    header+="$(printf '%*s' $type_padding '')"
    header+="│  ${scope_text}"

    echo "$header"

    # Generate separator line matching the header format
    local sep="  "
    # First column separator
    for ((i=0; i<max_server_len; i++)); do sep+="─"; done
    sep+="┼──"
    # Second column separator
    for ((i=0; i<max_type_len; i++)); do sep+="─"; done
    sep+="┼"
    # Third column separator
    for ((i=0; i<10; i++)); do sep+="─"; done

    echo "$sep"
}

# Generate fzf list from state file
# Output format: "● server-name  │  type  │  scope" with columnar alignment
generate_fzf_list() {
    if [[ ! -f "$STATE_FILE" ]] || [[ ! -s "$STATE_FILE" ]]; then
        echo ""
        return
    fi

    # First pass: calculate column widths
    local max_server_len=0
    local max_type_len=0

    while IFS=: read -r state server scope file source_type flags runtime; do
        [[ -z "$server" ]] && continue
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility

        local server_len=${#server}
        local type_len=0

        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            type_len=6  # "direct"
        elif [[ "$source_type" == "plugin" ]]; then
            type_len=6  # "plugin"
        else
            type_len=7  # "mcpjson"
        fi

        [[ $server_len -gt $max_server_len ]] && max_server_len=$server_len
        [[ $type_len -gt $max_type_len ]] && max_type_len=$type_len
    done < "$STATE_FILE"

    # Add padding
    max_server_len=$((max_server_len + 2))
    max_type_len=$((max_type_len + 2))

    # Second pass: format with calculated widths
    while IFS=: read -r state server scope file source_type flags runtime; do
        [[ -z "$server" ]] && continue
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility

        # Apply filter
        case "$FILTER_TYPE" in
            mcpjson)
                [[ "$source_type" != "mcpjson" ]] && continue
                ;;
            direct)
                [[ "$source_type" != "direct-global" && "$source_type" != "direct-local" ]] && continue
                ;;
            plugin)
                [[ "$source_type" != "plugin" ]] && continue
                ;;
            enterprise)
                [[ "$flags" != *"e"* ]] && continue
                ;;
            blocked)
                [[ "$flags" != *"b"* && "$flags" != *"r"* ]] && continue
                ;;
            orange)
                [[ "$state" != "on" || "$runtime" != "stopped" ]] && continue
                ;;
            all|*)
                # No filter, show all
                ;;
        esac

        # Determine state symbol and color (three-tier state system)
        local symbol=""
        local symbol_color=""

        # Check flags first (enterprise/blocked/restricted take precedence)
        if [[ "$flags" == *"e"* ]]; then
            # Enterprise-managed
            symbol="🏢 ●"
            symbol_color="${COLOR_CYAN}"
        elif [[ "$flags" == *"b"* ]]; then
            # Blocked by denylist
            symbol="🔒 ○"
            symbol_color="${COLOR_RED}"
        elif [[ "$flags" == *"r"* ]]; then
            # Restricted (not in allowlist)
            symbol="⚠️  ○"
            symbol_color="${COLOR_YELLOW}"
        elif [[ "$state" == "on" ]]; then
            # Check runtime status for three-tier state
            if [[ "$runtime" == "running" ]]; then
                # Fully active: enabled in config AND running
                symbol="●"
                symbol_color="${COLOR_GREEN}"
            elif [[ "$runtime" == "stopped" ]]; then
                # Intermediate: enabled in config but NOT running
                symbol="●"
                symbol_color="${COLOR_ORANGE}"
            else
                # Unknown runtime state, default to green for enabled
                symbol="●"
                symbol_color="${COLOR_GREEN}"
            fi
        else
            # Disabled in config
            symbol="○"
            symbol_color="${COLOR_RED}"
        fi

        # Determine type label
        local type_label=""
        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            type_label="direct"
        elif [[ "$source_type" == "plugin" ]]; then
            type_label="plugin"
        else
            type_label="mcpjson"
        fi

        # Calculate padding for this row
        local server_padding=$((max_server_len - ${#server}))
        local type_padding=$((max_type_len - ${#type_label}))

        # Build row with proper spacing (avoiding printf width specs with ANSI codes)
        local row="${symbol_color}${symbol}${COLOR_RESET} "
        row+="${server}"
        row+="$(printf '%*s' $server_padding '')"
        row+="${COLOR_CYAN}│${COLOR_RESET}"
        row+="  ${type_label}"
        row+="$(printf '%*s' $type_padding '')"
        row+="${COLOR_CYAN}│${COLOR_RESET}"
        row+="  ${scope}"

        echo -e "$row"
    done < "$STATE_FILE"
}

# ============================================================================
# ENTERPRISE UI COMPONENTS
# ============================================================================

# Show enterprise policy banner in TUI header
# Only displays if enterprise mode is active
show_enterprise_banner() {
    # Skip if no enterprise config
    [[ "$ENTERPRISE_MODE" == "none" ]] && return 0

    echo -e "${COLOR_YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}"
    echo -e "${COLOR_YELLOW}🏢 Enterprise Policies Active${COLOR_RESET}"

    # Show enterprise server count
    if [[ $ENTERPRISE_SERVER_COUNT -gt 0 ]]; then
        echo -e "   • ${COLOR_CYAN}${ENTERPRISE_SERVER_COUNT}${COLOR_RESET} enterprise-managed servers (cannot be modified)"
    fi

    # Show restriction type
    case "$RESTRICTION_TYPE" in
        allowlist)
            echo -e "   • ${COLOR_YELLOW}Access restricted to ${#ALLOWED_SERVERS[@]} approved servers${COLOR_RESET}"
            ;;
        denylist)
            echo -e "   • ${COLOR_RED}${#DENIED_SERVERS[@]} servers blocked by policy${COLOR_RESET}"
            ;;
        both)
            echo -e "   • ${COLOR_YELLOW}Allowlist (${#ALLOWED_SERVERS[@]}) and denylist (${#DENIED_SERVERS[@]}) active${COLOR_RESET}"
            ;;
    esac

    # Lockdown mode warning
    if [[ "$ENTERPRISE_MODE" == "lockdown" ]]; then
        echo -e "   • ${COLOR_RED}⚠️  LOCKDOWN MODE - Invalid config detected${COLOR_RESET}"
        echo -e "   • ${COLOR_RED}Only enterprise servers available${COLOR_RESET}"
    fi

    echo -e "${COLOR_YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}"
    echo ""
}

# Helper function to output preview lines with color support
# Args: $1 - text line
# Returns: formatted line with proper color rendering
preview_line() {
    local text="$1"
    echo -e "$text"
}

# Generate preview for selected server
# Args: $1 - full line from fzf (e.g., "[ON ] server-name (scope)")
generate_preview() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    if [[ -z "$server" ]]; then
        echo "No server selected"
        return
    fi

    # Find effective state, definition source, and source type from state file
    local current_state=""
    local def_scope=""
    local def_file=""
    local source_type=""
    local server_flags=""
    local runtime_status=""

    while IFS=: read -r state srv scope file stype flags runtime; do
        [[ -z "$flags" ]] && flags=""  # Backward compatibility
        [[ -z "$runtime" ]] && runtime="unknown"  # Backward compatibility
        if [[ "$srv" == "$server" ]]; then
            current_state="$state"
            def_scope="$scope"
            def_file="$file"
            source_type="$stype"
            server_flags="$flags"
            runtime_status="$runtime"
            break
        fi
    done < "$STATE_FILE"

    if [[ -z "$current_state" ]]; then
        echo "Server not found in state"
        return
    fi

    # Get all sources for this server from raw discovery
    local all_sources
    all_sources=$(discover_and_parse_all_sources | grep ":$server:")

    # Find where server is enabled/disabled (highest priority enable/disable directive)
    local state_scope=""
    local state_file=""
    local state_priority=0

    while IFS=: read -r type srv scope file; do
        if [[ "$type" == "enable" ]] || [[ "$type" == "disable" ]]; then
            local priority
            priority=$(get_scope_priority "$scope")
            if [[ $priority -gt $state_priority ]]; then
                state_priority=$priority
                state_scope="$scope"
                state_file="$file"
            fi
        fi
    done <<< "$all_sources"

    # Add padding to align with table header in main list
    # (3 lines: 2 shortcut lines + 1 separator line before table header)
    preview_line ""
    preview_line ""
    preview_line ""

    # Box header
    preview_line "╭─────────────────────────────────────────────────╮"
    preview_line ""
    preview_line " ${COLOR_WHITE}${server}${COLOR_RESET}"
    preview_line ""

    # Direct server preview
    if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
        preview_line " ${COLOR_CYAN}Source Type${COLOR_RESET}"
        if [[ "$source_type" == "direct-global" ]]; then
            preview_line "   ${COLOR_YELLOW}Direct (global)${COLOR_RESET}"
        else
            preview_line "   ${COLOR_YELLOW}Direct (local)${COLOR_RESET}"
        fi
        preview_line ""

        preview_line " ${COLOR_CYAN}Definition${COLOR_RESET}"
        preview_line "   Scope: $def_scope"
        preview_line "   File:  $(abbreviate_path "$def_file")"
        preview_line ""

        preview_line " ${COLOR_CYAN}Status & Control${COLOR_RESET}"
        if [[ "$current_state" == "off" ]]; then
            preview_line "   ${COLOR_RED}● Disabled${COLOR_RESET} (quick-disable)"
            preview_line "   Disabled via ${COLOR_CYAN}~/.claude.json${COLOR_RESET}"
            preview_line "   Location: .projects[cwd]"
            preview_line "   Definition remains global"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to re-enable${COLOR_RESET}"
            preview_line " ${COLOR_CYAN}Press ALT-M to migrate${COLOR_RESET}"
        else
            preview_line "   ${COLOR_GREEN}● Enabled${COLOR_RESET}"
            preview_line "   In: ${COLOR_CYAN}$(abbreviate_path "$def_file")${COLOR_RESET}"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to quick-disable${COLOR_RESET}"
            preview_line " ${COLOR_CYAN}Press ALT-M to migrate${COLOR_RESET}"
        fi

        preview_line ""
        preview_line " ${COLOR_WHITE}Quick Disable${COLOR_RESET} - Modifies global"
        preview_line " ${COLOR_WHITE}Migration${COLOR_RESET} - Full project control"
        preview_line ""
        preview_line "╰─────────────────────────────────────────────────╯"
        return
    fi

    # Plugin server preview
    if [[ "$source_type" == "plugin" ]]; then
        preview_line " ${COLOR_CYAN}Source Type${COLOR_RESET}"
        preview_line "   ${COLOR_BLUE}Marketplace Plugin${COLOR_RESET}"
        preview_line ""

        preview_line " ${COLOR_CYAN}Definition${COLOR_RESET}"
        preview_line "   Scope: $def_scope"
        preview_line "   File:  $(abbreviate_path "$def_file")"
        preview_line ""

        preview_line " ${COLOR_CYAN}Status & Control${COLOR_RESET}"
        if [[ "$current_state" == "off" ]]; then
            preview_line "   ${COLOR_RED}● Disabled${COLOR_RESET} in config"
            if [[ -n "$state_scope" ]]; then
                preview_line "   From: ${COLOR_CYAN}$(abbreviate_path "$state_file")${COLOR_RESET}"
                preview_line "   ($state_scope)"
            fi
            preview_line "   Via ${COLOR_CYAN}enabledPlugins${COLOR_RESET}"
            preview_line "   Hidden from Claude menu"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to enable${COLOR_RESET}"
        else
            # Check runtime status for three-tier state
            if [[ "$runtime_status" == "running" ]]; then
                preview_line "   ${COLOR_GREEN}● Fully Active${COLOR_RESET}"
                preview_line "   Config: enabled"
                preview_line "   Runtime: running"
            elif [[ "$runtime_status" == "stopped" ]]; then
                preview_line "   ${COLOR_ORANGE}● Configured but Not Running${COLOR_RESET}"
                preview_line "   Config: enabled"
                preview_line "   Runtime: stopped"
                preview_line "   ${COLOR_YELLOW}Note:${COLOR_RESET} Enable in Claude /mcp to activate"
            else
                preview_line "   ${COLOR_GREEN}● Enabled${COLOR_RESET} in config"
                preview_line "   Runtime: unknown"
            fi
            if [[ -n "$state_scope" ]]; then
                preview_line "   From: ${COLOR_CYAN}$(abbreviate_path "$state_file")${COLOR_RESET}"
                preview_line "   ($state_scope)"
            fi
            preview_line "   Via ${COLOR_CYAN}enabledPlugins${COLOR_RESET}"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to disable${COLOR_RESET}"
        fi

        preview_line ""
        preview_line " ${COLOR_YELLOW}Note:${COLOR_RESET} Delete via Claude menu"
        preview_line ""
        preview_line " Changes write to:"
        preview_line "   ./.claude/settings.local.json"
        preview_line ""
        preview_line "╰─────────────────────────────────────────────────╯"
        return
    fi

    # MCPJSON server preview
    preview_line " ${COLOR_CYAN}Source Type${COLOR_RESET}"
    preview_line "   ${COLOR_GREEN}MCP.json${COLOR_RESET} (controllable)"
    preview_line ""

    preview_line " ${COLOR_CYAN}Definition${COLOR_RESET}"
    preview_line "   Scope: $def_scope"
    preview_line "   File:  $def_file"
    preview_line ""

    preview_line " ${COLOR_CYAN}Status${COLOR_RESET}"
    if [[ "$current_state" == "on" ]]; then
        preview_line "   ${COLOR_GREEN}● Enabled${COLOR_RESET}"
    else
        preview_line "   ${COLOR_RED}● Disabled${COLOR_RESET}"
    fi
    preview_line ""

    preview_line " ${COLOR_CYAN}Press SPACE to toggle${COLOR_RESET}"
    preview_line ""

    preview_line " ${COLOR_YELLOW}Changes write to:${COLOR_RESET}"
    preview_line "   ./.claude/settings.local.json"
    preview_line ""
    preview_line "╰─────────────────────────────────────────────────╯"
}

# ============================================================================
# SERVER MANAGEMENT FLOWS
# ============================================================================

# Interactive flow to add a new server
add_server_flow() {
    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_CYAN}Add New Server${COLOR_RESET}"
    echo ""
    read -rp "Enter server name (or press Enter to cancel): " server_name

    if [[ -z "$server_name" ]]; then
        echo "Cancelled"
        sleep 0.5
        return 0
    fi

    if add_server "$server_name"; then
        msg_success "Added $server_name"
        sleep 0.5
    else
        sleep 1
    fi
}

# Interactive flow to remove a server
# Args: $1 - server line from fzf
remove_server_flow() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    if [[ -z "$server" ]]; then
        return 0
    fi

    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_YELLOW}Remove Server: ${COLOR_WHITE}$server${COLOR_RESET}"
    echo ""
    read -rp "Are you sure? (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        remove_server "$server"
        msg_success "Removed $server"
        sleep 0.5
    else
        echo "Cancelled"
        sleep 0.5
    fi
}

# Migration flow for Direct servers (Option B - Alternative)
# Args: $1 - server line from fzf
migrate_direct_server_flow() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    if [[ -z "$server" ]]; then
        return 0
    fi

    # Check if this is a Direct server
    local source_type
    source_type=$(get_server_source_type "$server")

    if [[ "$source_type" != "direct-global" ]] && [[ "$source_type" != "direct-local" ]]; then
        # Redirect to tty for message
        exec < /dev/tty
        echo ""
        msg_warning "Migration only available for Direct servers"
        sleep 1
        return 0
    fi

    # Get definition location
    local location def_file
    location=$(get_server_definition_location "$server")
    def_file=$(echo "$location" | cut -d: -f2-)

    # Existing migration prompt and logic
    if prompt_for_migration "$server" "$source_type" "$def_file"; then
        if migrate_server_to_project_mcpjson "$server"; then
            load_servers
            msg_info "Reloaded server list - server is now controllable"
            sleep 1
        else
            msg_error "Migration failed"
            sleep 2
        fi
    fi
}

# ============================================================================
# MAIN TUI LAUNCHER
# ============================================================================

# Launch fzf TUI with all bindings and interactions
launch_fzf_tui() {
    # Export current directory and functions for fzf subshells (preview runs in different pwd)
    export MCP_CURRENT_DIR="$(pwd)"
    export STATE_FILE
    export COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_BLUE COLOR_CYAN COLOR_WHITE COLOR_ORANGE COLOR_GREY
    export MARK_ERROR MARK_SUCCESS MARK_WARNING MARK_INFO
    export -f msg_header gen_line get_term_width abbreviate_path extract_server_name
    export -f toggle_server generate_fzf_list generate_table_header add_server remove_server
    export -f enable_all_servers disable_all_servers preview_line
    export -f strip_ansi visual_width truncate_text
    export -f add_server_flow remove_server_flow migrate_direct_server_flow msg_error msg_warning msg_success msg_info
    export -f discover_and_parse_all_sources get_scope_priority generate_preview get_runtime_servers is_server_running
    export -f parse_settings_file parse_mcp_json_file parse_claude_json_file detect_file_format
    export -f parse_plugin_marketplace_files parse_enabled_plugins
    export -f is_server_migrated mark_server_migrated get_server_source_type
    export -f plugin_enabled_in_lower_scope get_project_plugin_value
    export -f get_server_definition_location extract_server_definition
    export -f migrate_server_to_project_mcpjson prompt_for_migration load_servers
    # Enterprise functions (Phase 6)
    export -f get_enterprise_mcp_path get_enterprise_settings_path
    export -f parse_enterprise_mcp_json parse_enterprise_restrictions
    export -f server_in_allowlist server_in_denylist is_server_allowed
    export -f show_toggle_error show_enterprise_banner
    # Enterprise globals
    export ENTERPRISE_MODE ENTERPRISE_SERVER_COUNT RESTRICTION_TYPE
    export ALLOWED_SERVERS DENIED_SERVERS

    clear

    # Count servers by scope
    local total_count=0
    local enabled_count=0
    local local_count=0
    local project_count=0
    local user_count=0

    if [[ -f "$STATE_FILE" ]] && [[ -s "$STATE_FILE" ]]; then
        total_count=$(wc -l < "$STATE_FILE")
        enabled_count=$(grep -c '^on:' "$STATE_FILE" 2>/dev/null || true)
        local_count=$(grep -c ':local:' "$STATE_FILE" 2>/dev/null || true)
        project_count=$(grep -c ':project:' "$STATE_FILE" 2>/dev/null || true)
        user_count=$(grep -c ':user:' "$STATE_FILE" 2>/dev/null || true)
        : ${enabled_count:=0}
        : ${local_count:=0}
        : ${project_count:=0}
        : ${user_count:=0}
    fi

    # Display ASCII art title with Claude Code orange
    echo -e "${COLOR_ORANGE}███╗   ███╗ ██████╗██████╗     ███████╗███████╗██╗     ███████╗ ██████╗████████╗ ██████╗ ██████╗${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}████╗ ████║██╔════╝██╔══██╗    ██╔════╝██╔════╝██║     ██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}██╔████╔██║██║     ██████╔╝    ███████╗█████╗  ██║     █████╗  ██║        ██║   ██║   ██║██████╔╝${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}██║╚██╔╝██║██║     ██╔═══╝     ╚════██║██╔══╝  ██║     ██╔══╝  ██║        ██║   ██║   ██║██╔══██╗${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}██║ ╚═╝ ██║╚██████╗██║         ███████║███████╗███████╗███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}╚═╝     ╚═╝ ╚═════╝╚═╝         ╚══════╝╚══════╝╚══════╝╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝${COLOR_RESET}"
    echo ""

    # Calculate percentages
    local enabled_pct=0
    if [[ $total_count -gt 0 ]]; then
        enabled_pct=$((enabled_count * 100 / total_count))
    fi

    # Compact info bar with write target
    echo -e "${COLOR_CYAN}Write →${COLOR_RESET} ./.claude/settings.local.json  ${COLOR_WHITE}│${COLOR_RESET}  ${COLOR_GREEN}Enabled: ${enabled_count}/${total_count} (${enabled_pct}%)${COLOR_RESET}"
    echo ""

    # Show enterprise banner if applicable (Phase 6)
    show_enterprise_banner

    # Generate dynamic table header that matches column widths
    local table_header
    table_header=$(generate_table_header)

    # Build filter indicator
    local filter_indicator=""
    case "$FILTER_TYPE" in
        mcpjson) filter_indicator=" [Filter: MCPJSON]" ;;
        direct) filter_indicator=" [Filter: Direct]" ;;
        plugin) filter_indicator=" [Filter: Plugin]" ;;
        enterprise) filter_indicator=" [Filter: Enterprise]" ;;
        blocked) filter_indicator=" [Filter: Blocked]" ;;
        orange) filter_indicator=" [Filter: ORANGE]" ;;
        *) filter_indicator="" ;;
    esac

    # Compact shortcuts and table header for fzf header (split into multiple lines)
    local header=""
    header="
SPACE:Toggle │ ALT-M:Migrate │ ALT-H:Hard-Disable │ CTRL-A:Add │ CTRL-X:Delete
ALT-E:Enable All │ ALT-D:Disable All │ ENTER:Save │ ESC:Cancel
Filters: ALT-1:MCPJSON │ ALT-2:Direct │ ALT-3:Plugin │ ALT-4:Enterprise │ ALT-0:All${filter_indicator}

$table_header"

    # Run fzf with dynamic bindings
    set +e  # Don't exit on fzf cancel

    generate_fzf_list | fzf \
        --ansi \
        --multi \
        --reverse \
        --height=80% \
        --border=rounded \
        --prompt="  Filter: " \
        --pointer="►" \
        --marker="●" \
        --info=inline \
        --header="$header" \
        --preview="generate_preview {}" \
        --preview-window="right:45%:wrap" \
        --bind="space:execute(toggle_server {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-m:execute(migrate_direct_server_flow {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-h:execute(hard_disable_plugin {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-e:execute-silent(enable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-d:execute-silent(disable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-a:execute(add_server_flow)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-x:execute(remove_server_flow {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-1:execute-silent(set_filter_mcpjson)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-2:execute-silent(set_filter_direct)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-3:execute-silent(set_filter_plugin)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-4:execute-silent(set_filter_enterprise)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-0:execute-silent(set_filter_all)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-b:execute-silent(set_filter_blocked)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-o:execute-silent(set_filter_orange)+reload(generate_fzf_list)+refresh-preview" \
        --bind="enter:accept" \
        --bind="esc:abort" \
        --color="fg:#d0d0d0,bg:#121212,hl:#5fff87" \
        --color="fg+:#ffffff,bg+:#262626,hl+:#ffff00" \
        --color="info:#af87ff,prompt:#5fff87,pointer:#ff87d7" \
        --color="marker:#00ff00,spinner:#ff87d7,header:#808080" \
        > /dev/null

    local fzf_exit=$?
    set -e

    # Handle exit code
    if [[ $fzf_exit -eq 130 ]] || [[ $fzf_exit -eq 1 ]]; then
        # User cancelled (ESC or Ctrl-C)
        clear
        msg_warning "Cancelled - no changes saved"
        return 1
    elif [[ $fzf_exit -eq 0 ]]; then
        # User confirmed
        clear
        msg_success "Saving changes..."
        save_state_to_settings

        # Show summary
        local new_enabled_count
        new_enabled_count=$(grep -c '^on:' "$STATE_FILE" 2>/dev/null || true)
        : ${new_enabled_count:=0}

        echo ""
        if [[ $new_enabled_count -eq 0 ]]; then
            msg_warning "No servers enabled"
        else
            # Count GREEN vs ORANGE servers
            local green_count=0
            local orange_count=0
            while IFS=: read -r state server scope file source_type flags runtime; do
                [[ -z "$runtime" ]] && runtime="unknown"
                if [[ "$state" == "on" ]]; then
                    if [[ "$runtime" == "stopped" ]]; then
                        ((orange_count++))
                    else
                        ((green_count++))
                    fi
                fi
            done < "$STATE_FILE"

            # Show GREEN servers (will run)
            if [[ $green_count -gt 0 ]]; then
                echo -e "${COLOR_GREEN}Will start (${green_count}):${COLOR_RESET}"
                while IFS=: read -r state server scope file source_type flags runtime; do
                    [[ -z "$flags" ]] && flags=""
                    [[ -z "$runtime" ]] && runtime="unknown"
                    if [[ "$state" == "on" ]] && [[ "$runtime" != "stopped" ]]; then
                        local dim='\033[2m'
                        echo -e "  ${COLOR_GREEN}✓${COLOR_RESET} $server ${dim}($scope, $source_type)${COLOR_RESET}"
                    fi
                done < "$STATE_FILE"
                echo ""
            fi

            # Show ORANGE servers (available but runtime-disabled)
            if [[ $orange_count -gt 0 ]]; then
                echo -e "${COLOR_ORANGE}Available but disabled (${orange_count}):${COLOR_RESET}"
                while IFS=: read -r state server scope file source_type flags runtime; do
                    [[ -z "$flags" ]] && flags=""
                    [[ -z "$runtime" ]] && runtime="unknown"
                    if [[ "$state" == "on" ]] && [[ "$runtime" == "stopped" ]]; then
                        local dim='\033[2m'
                        echo -e "  ${COLOR_ORANGE}◐${COLOR_RESET} $server ${dim}($scope, $source_type - runtime disabled)${COLOR_RESET}"
                    fi
                done < "$STATE_FILE"
                echo ""
            fi
        fi

        echo ""
        return 0
    else
        msg_error "Unexpected error (exit code: $fzf_exit)"
        return 1
    fi
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

main() {
    # Parse command-line arguments first
    parse_args "$@"

    # Handle commands that don't need any dependencies or state file
    case "$CMD_MODE" in
        help)
            show_help
            exit 0
            ;;
    esac

    # Commands that only need jq (not fzf)
    case "$CMD_MODE" in
        validate|audit|debug|fix|restore|rollback|export|sync|context|enable|disable)
            if ! command -v jq &> /dev/null; then
                msg_error "Missing required dependency: jq"
                msg_info "Install with: sudo apt install jq"
                exit 1
            fi

            # Set up state file for commands that need discovery
            if [[ "$CMD_MODE" != "validate" && "$CMD_MODE" != "rollback" ]]; then
                STATE_FILE=$(mktemp)
                trap 'rm -f "$STATE_FILE"' EXIT
            fi

            case "$CMD_MODE" in
                validate)
                    run_validate
                    exit $?
                    ;;
                audit)
                    run_audit
                    exit $?
                    ;;
                debug)
                    run_debug_precedence "$CMD_ARG"
                    exit $?
                    ;;
                fix)
                    run_fix_config
                    exit $?
                    ;;
                restore)
                    run_restore_plugin "$CMD_ARG"
                    exit $?
                    ;;
                rollback)
                    run_rollback
                    exit $?
                    ;;
                export)
                    run_export_disabled
                    exit $?
                    ;;
                sync)
                    run_sync_check
                    exit $?
                    ;;
                context)
                    run_context_report
                    exit $?
                    ;;
                enable)
                    run_enable_servers
                    exit $?
                    ;;
                disable)
                    run_disable_servers
                    exit $?
                    ;;
            esac
            ;;
    esac

    # TUI mode - full initialization
    # Set up cleanup trap for state file
    STATE_FILE=$(mktemp)
    trap 'rm -f "$STATE_FILE"' EXIT

    # Check all dependencies (jq + fzf)
    check_dependencies

    # Discover settings file (may trigger new project flow)
    discover_settings_file

    # Load servers into state file with progress indicator
    msg_progress "Discovering MCP servers and checking states..." &
    local progress_pid=$!
    load_servers
    stop_progress "$progress_pid"
    msg_success "Configuration loaded"

    # Check if running inside a Claude session
    check_session_context

    # Apply strict-disable if requested
    if [[ "$STRICT_DISABLE" == "true" ]]; then
        apply_strict_disable
    fi

    # Launch TUI
    if launch_fzf_tui; then
        # Success - launch Claude Code (unless in test mode)
        if [[ -n "${TEST_MODE:-}" ]]; then
            msg_success "Test mode - skipping Claude Code launch"
            exit 0
        fi

        msg_info "Launching Claude Code..."
        sleep 0.5

        # Find claude binary
        local claude_bin
        if [[ -L "$HOME/.local/bin/claude" ]]; then
            claude_bin=$(realpath_portable "$HOME/.local/bin/claude")
        elif command -v claude &> /dev/null; then
            claude_bin=$(command -v claude)
        else
            msg_error "Cannot find claude binary"
            exit 1
        fi

        exec "$claude_bin" "${CLAUDE_ARGS[@]}"
    else
        # User cancelled
        exit 0
    fi
}

# Global array for Claude arguments (set by parse_args)
declare -a CLAUDE_ARGS=()

# ============================================================================
# ENTRY POINT
# ============================================================================

main "$@"
